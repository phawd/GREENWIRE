Proposed changes in 90 files:

Changes for .\apdu4j_data\apdu4j_cli.py:
--- original excerpt ---
#!/usr/bin/env python3
"""APDU4J CLI Integration for GREENWIRE.

Extends GREENWIRE's command-line interface with APDU4J functionality,
providing access to hardcoded APDU command libraries and GlobalPlatform operations.
"""

import sys
import os
import argparse
import logging
from typing import Dict, List, Optional, Any

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from apdu4j_data.apdu4j_integration import GREENWIREAPDU4JInterface, create_apdu4j_interface
from apdu_communicator import APDUCommunicator

logger = logging.getLogger(__name__)

class APDU4JCLIHandler:
    """CLI handler for APDU4J operations in GREENWIRE."""
    
    def __init__(self):
        """Initialize CLI handler."""
        self.communicator = None
        self.apdu4j_interface = None
        
    def setup_connection(self, reader_name: str = None, verbose: bool = False) -> bool:
        """Setup APDU communication connection.
        
        Args:
            reader_name: Specific reader to use (optional)
            verbose: Enable verbose APDU logging
            
        Returns:
            True if connection successful
        """
        try:
            self.communicator = APDUCommunicator(verbose=verbose)
            
            if self.communicator.connect_reader(reader_name):
                self.apdu4j_interface = create_apdu4j_interface(self.communicator)
                if verbose:
                    print(f"✅ Connected to reader: {self.communicator.reader_name}")
                    atr = self.communicator.get_atr()
                    if atr:
                        print(f"📋 Card ATR: {atr}")
                return True
--- proposed excerpt ---
#!/usr/bin/env python3
"""APDU4J CLI Integration for GREENWIRE.

Extends GREENWIRE's command-line interface with APDU4J functionality,
providing access to hardcoded APDU command libraries and GlobalPlatform operations.
"""

import argparse, logging, os, sys
from typing import Any, Dict, List, Optional  # noqa: F401

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from apdu4j_data.apdu4j_integration import GREENWIREAPDU4JInterface, create_apdu4j_interface
from apdu_communicator import APDUCommunicator

logger = logging.getLogger(__name__)

class APDU4JCLIHandler:
    """CLI handler for APDU4J operations in GREENWIRE."""
    
    def __init__(self):
        """Initialize CLI handler."""
        self.communicator = None
        self.apdu4j_interface = None
        
    def setup_connection(self, reader_name: str = None, verbose: bool = False) -> bool:
        """Setup APDU communication connection.
        
        Args:
            reader_name: Specific reader to use (optional)
            verbose: Enable verbose APDU logging
            
        Returns:
            True if connection successful
        """
        try:
            self.communicator = APDUCommunicator(verbose=verbose)
            
            if self.communicator.connect_reader(reader_name):
                self.apdu4j_interface = create_apdu4j_interface(self.communicator)
                if verbose:
                    print(f"✅ Connected to reader: {self.communicator.reader_name}")
                    atr = self.communicator.get_atr()
                    if atr:
                        print(f"📋 Card ATR: {atr}")
                return True
            else:
                print("❌ Failed to connect to card reader")
                return False
(dry-run)

Changes for .\apdu4j_data\apdu4j_integration.py:
--- original excerpt ---
#!/usr/bin/env python3
"""APDU4J Integration Module for GREENWIRE.

Main integration interface that combines APDU4J command structures with GREENWIRE's
existing EMV and smartcard infrastructure. Provides unified access to hardcoded
APDU commands from the martinpaljak/apdu4j library.

Source: https://github.com/martinpaljak/apdu4j
License: MIT
"""

import logging
from typing import Dict, List, Optional, Union, Any
from .apdu_commands import (
    APDU4JCommand, APDU4JInterface, APDU_COMMANDS, PCSC_COMMANDS,
    create_select_aid_command, create_pin_verify_command, create_get_data_command,
    parse_apdu_response
)
from .gp_commands import GPCommand, GPManager, GPCapFileLoader, GP_COMMANDS

logger = logging.getLogger(__name__)

class GREENWIREAPDU4JInterface:
    """Main APDU4J integration interface for GREENWIRE."""
    
    def __init__(self, apdu_communicator=None):
        """Initialize APDU4J interface.
        
        Args:
            apdu_communicator: GREENWIRE APDUCommunicator instance
        """
        self.communicator = apdu_communicator
        self.apdu_interface = APDU4JInterface(apdu_communicator)
        self.gp_manager = GPManager(apdu_communicator)
        self.logger = logging.getLogger(__name__)
        
        # Load all available commands
        self.commands = {}
        self.commands.update(APDU_COMMANDS)
        self.commands.update(PCSC_COMMANDS)
        self.commands.update(GP_COMMANDS)
        
    def get_available_commands(self) -> List[str]:
        """Get list of all available APDU4J commands.
        
        Returns:
            List of command names
        """
        return list(self.commands.keys())
        
--- proposed excerpt ---
#!/usr/bin/env python3
"""APDU4J Integration Module for GREENWIRE.

Main integration interface that combines APDU4J command structures with GREENWIRE's
existing EMV and smartcard infrastructure. Provides unified access to hardcoded
APDU commands from the martinpaljak/apdu4j library.

Source: https://github.com/martinpaljak/apdu4j
License: MIT
"""

import logging
from typing import Any, Dict, List, Optional, Union
from .apdu_commands import (
    APDU4JCommand, APDU4JInterface, APDU_COMMANDS, PCSC_COMMANDS,
    create_select_aid_command, create_pin_verify_command, create_get_data_command,
    parse_apdu_response
)
from .gp_commands import GPCapFileLoader, GPCommand, GPManager, GP_COMMANDS  # noqa: F401

logger = logging.getLogger(__name__)

class GREENWIREAPDU4JInterface:
    """Main APDU4J integration interface for GREENWIRE."""
    
    def __init__(self, apdu_communicator=None):
        """Initialize APDU4J interface.
        
        Args:
            apdu_communicator: GREENWIRE APDUCommunicator instance
        """
        self.communicator = apdu_communicator
        self.apdu_interface = APDU4JInterface(apdu_communicator)
        self.gp_manager = GPManager(apdu_communicator)
        self.logger = logging.getLogger(__name__)
        
        # Load all available commands
        self.commands = {}
        self.commands.update(APDU_COMMANDS)
        self.commands.update(PCSC_COMMANDS)
        self.commands.update(GP_COMMANDS)
        
    def get_available_commands(self) -> List[str]:
        """Get list of all available APDU4J commands.
        
        Returns:
            List of command names
        """
        return list(self.commands.keys())
        
(dry-run)

Changes for .\apdu4j_data\apdu_commands.py:
--- original excerpt ---
#!/usr/bin/env python3
"""APDU4J Command Definitions for GREENWIRE Integration.

Hardcoded APDU command structures and constants extracted from martinpaljak/apdu4j
CommandAPDU.java implementation with full ISO 7816-4 compliance.

Source: https://github.com/martinpaljak/apdu4j
License: MIT (following original project)
"""

from typing import Dict, List, Optional, Union, Tuple
import logging

logger = logging.getLogger(__name__)

# ISO 7816-4 APDU Cases (from CommandAPDU.java)
APDU_CASE_1 = 1  # No data, no response expected
APDU_CASE_2S = 2  # No data, response expected (short Le)
APDU_CASE_2E = 22  # No data, response expected (extended Le)
APDU_CASE_3S = 3  # Data sent, no response expected (short Lc)
APDU_CASE_3E = 33  # Data sent, no response expected (extended Lc)
APDU_CASE_4S = 4  # Data sent, response expected (short Lc, Le)
APDU_CASE_4E = 44  # Data sent, response expected (extended Lc, Le)

# ISO 7816-4 Status Words
SW_SUCCESS = 0x9000
SW_MORE_DATA = 0x6100
SW_WRONG_LENGTH = 0x6700
SW_SECURITY_NOT_SATISFIED = 0x6982
SW_FILE_NOT_FOUND = 0x6A82
SW_WRONG_PARAMETERS = 0x6A86
SW_INSTRUCTION_NOT_SUPPORTED = 0x6D00
SW_CLASS_NOT_SUPPORTED = 0x6E00

# Common CLA (Class) bytes
CLA_ISO = 0x00      # ISO 7816-4 standard class
CLA_PROPRIETARY = 0x80  # Proprietary class
CLA_SECURE_MSG = 0x04   # Secure messaging

# Common INS (Instruction) bytes
INS_SELECT = 0xA4       # SELECT command
INS_READ_BINARY = 0xB0  # READ BINARY
INS_UPDATE_BINARY = 0xD6 # UPDATE BINARY
INS_READ_RECORD = 0xB2   # READ RECORD
INS_UPDATE_RECORD = 0xDC # UPDATE RECORD
INS_APPEND_RECORD = 0xE2 # APPEND RECORD
INS_GET_DATA = 0xCA      # GET DATA
INS_PUT_DATA = 0xDA      # PUT DATA
INS_VERIFY = 0x20        # VERIFY PIN
INS_CHANGE_PIN = 0x24    # CHANGE PIN
--- proposed excerpt ---
#!/usr/bin/env python3
"""APDU4J Command Definitions for GREENWIRE Integration.

Hardcoded APDU command structures and constants extracted from martinpaljak/apdu4j
CommandAPDU.java implementation with full ISO 7816-4 compliance.

Source: https://github.com/martinpaljak/apdu4j
License: MIT (following original project)
"""

from typing import Dict, List, Optional, Tuple, Union  # noqa: F401
import logging

logger = logging.getLogger(__name__)

# ISO 7816-4 APDU Cases (from CommandAPDU.java)
APDU_CASE_1 = 1  # No data, no response expected
APDU_CASE_2S = 2  # No data, response expected (short Le)
APDU_CASE_2E = 22  # No data, response expected (extended Le)
APDU_CASE_3S = 3  # Data sent, no response expected (short Lc)
APDU_CASE_3E = 33  # Data sent, no response expected (extended Lc)
APDU_CASE_4S = 4  # Data sent, response expected (short Lc, Le)
APDU_CASE_4E = 44  # Data sent, response expected (extended Lc, Le)

# ISO 7816-4 Status Words
SW_SUCCESS = 0x9000
SW_MORE_DATA = 0x6100
SW_WRONG_LENGTH = 0x6700
SW_SECURITY_NOT_SATISFIED = 0x6982
SW_FILE_NOT_FOUND = 0x6A82
SW_WRONG_PARAMETERS = 0x6A86
SW_INSTRUCTION_NOT_SUPPORTED = 0x6D00
SW_CLASS_NOT_SUPPORTED = 0x6E00

# Common CLA (Class) bytes
CLA_ISO = 0x00      # ISO 7816-4 standard class
CLA_PROPRIETARY = 0x80  # Proprietary class
CLA_SECURE_MSG = 0x04   # Secure messaging

# Common INS (Instruction) bytes
INS_SELECT = 0xA4       # SELECT command
INS_READ_BINARY = 0xB0  # READ BINARY
INS_UPDATE_BINARY = 0xD6 # UPDATE BINARY
INS_READ_RECORD = 0xB2   # READ RECORD
INS_UPDATE_RECORD = 0xDC # UPDATE RECORD
INS_APPEND_RECORD = 0xE2 # APPEND RECORD
INS_GET_DATA = 0xCA      # GET DATA
INS_PUT_DATA = 0xDA      # PUT DATA
INS_VERIFY = 0x20        # VERIFY PIN
INS_CHANGE_PIN = 0x24    # CHANGE PIN
(dry-run)

Changes for .\apdu4j_data\gp_commands.py:
--- original excerpt ---
#!/usr/bin/env python3
"""APDU4J GlobalPlatform Integration for GREENWIRE.

Hardcoded GlobalPlatform commands and utilities extracted from martinpaljak/apdu4j
and GlobalPlatformPro implementations for smartcard application management.

Source: https://github.com/martinpaljak/apdu4j
Related: https://github.com/martinpaljak/GlobalPlatformPro
License: MIT
"""

from typing import Dict, List, Optional, Union, Tuple
import logging
from .apdu_commands import APDU4JCommand, CLA_ISO

logger = logging.getLogger(__name__)

# GlobalPlatform specific constants
GP_CLA = 0x80  # GlobalPlatform class byte

# GlobalPlatform INS codes
GP_INS_SELECT = 0xA4
GP_INS_GET_STATUS = 0xF2
GP_INS_INSTALL = 0xE6
GP_INS_LOAD = 0xE8  
GP_INS_DELETE = 0xE4
GP_INS_GET_DATA = 0xCA
GP_INS_PUT_KEY = 0xD8
GP_INS_SET_STATUS = 0xF0
GP_INS_STORE_DATA = 0xE2

# GlobalPlatform Application States
GP_APP_INSTALLED = 0x03
GP_APP_SELECTABLE = 0x07
GP_APP_LOCKED = 0x83

# Well-known AIDs
GP_CARD_MANAGER_AID = "A000000151000000"
GP_ISD_AID = "A000000003000000"

# Install parameters
GP_INSTALL_FOR_LOAD = 0x02
GP_INSTALL_FOR_INSTALL = 0x04
GP_INSTALL_FOR_MAKE_SELECTABLE = 0x08
GP_INSTALL_FOR_PERSONALIZATION = 0x20

class GPCommand:
    """GlobalPlatform command builder following apdu4j patterns."""
    
    @staticmethod
--- proposed excerpt ---
#!/usr/bin/env python3
"""APDU4J GlobalPlatform Integration for GREENWIRE.

Hardcoded GlobalPlatform commands and utilities extracted from martinpaljak/apdu4j
and GlobalPlatformPro implementations for smartcard application management.

Source: https://github.com/martinpaljak/apdu4j
Related: https://github.com/martinpaljak/GlobalPlatformPro
License: MIT
"""

from typing import Dict, List, Optional, Tuple, Union  # noqa: F401
import logging
from .apdu_commands import APDU4JCommand, CLA_ISO

logger = logging.getLogger(__name__)

# GlobalPlatform specific constants
GP_CLA = 0x80  # GlobalPlatform class byte

# GlobalPlatform INS codes
GP_INS_SELECT = 0xA4
GP_INS_GET_STATUS = 0xF2
GP_INS_INSTALL = 0xE6
GP_INS_LOAD = 0xE8  
GP_INS_DELETE = 0xE4
GP_INS_GET_DATA = 0xCA
GP_INS_PUT_KEY = 0xD8
GP_INS_SET_STATUS = 0xF0
GP_INS_STORE_DATA = 0xE2

# GlobalPlatform Application States
GP_APP_INSTALLED = 0x03
GP_APP_SELECTABLE = 0x07
GP_APP_LOCKED = 0x83

# Well-known AIDs
GP_CARD_MANAGER_AID = "A000000151000000"
GP_ISD_AID = "A000000003000000"

# Install parameters
GP_INSTALL_FOR_LOAD = 0x02
GP_INSTALL_FOR_INSTALL = 0x04
GP_INSTALL_FOR_MAKE_SELECTABLE = 0x08
GP_INSTALL_FOR_PERSONALIZATION = 0x20

class GPCommand:
    """GlobalPlatform command builder following apdu4j patterns."""
    
    @staticmethod
(dry-run)

Changes for .\apdu4j_data\test_apdu4j.py:
--- original excerpt ---
#!/usr/bin/env python3
"""Test Suite for APDU4J Integration with GREENWIRE.

Comprehensive testing of APDU4J command structures, GlobalPlatform commands,
and integration with GREENWIRE's existing smartcard infrastructure.
"""

import sys
import os
import logging
import unittest
from unittest.mock import Mock, patch

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from apdu4j_data.apdu_commands import (
    APDU4JCommand, APDU4JInterface, APDU_COMMANDS, PCSC_COMMANDS,
    create_select_aid_command, create_pin_verify_command, create_get_data_command,
    parse_apdu_response, SW_SUCCESS, APDU_CASE_1, APDU_CASE_2S, APDU_CASE_4S
)
from apdu4j_data.gp_commands import GPCommand, GPManager, GP_COMMANDS
from apdu4j_data.apdu4j_integration import GREENWIREAPDU4JInterface, create_apdu4j_interface

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TestAPDU4JCommand(unittest.TestCase):
    """Test APDU4J command structure and encoding."""
    
    def test_case_1_apdu(self):
        """Test Case 1 APDU (no data, no response)."""
        cmd = APDU4JCommand(0x00, 0xA4, 0x00, 0x0C)
        
        self.assertEqual(cmd.case, APDU_CASE_1)
        self.assertEqual(cmd.to_hex(), "00A4000C")
        self.assertEqual(len(cmd.to_bytes()), 4)
        
    def test_case_2s_apdu(self):
        """Test Case 2S APDU (no data, short Le)."""
        cmd = APDU4JCommand(0x00, 0xCA, 0x00, 0x00, le=256)
        
        self.assertEqual(cmd.case, APDU_CASE_2S)
        self.assertEqual(cmd.to_hex(), "00CA000000")  # Le=256 encoded as 00
        self.assertEqual(len(cmd.to_bytes()), 5)
        
    def test_case_4s_apdu(self):
        """Test Case 4S APDU (short data, short Le)."""
        pin_data = b"1234"
--- proposed excerpt ---
#!/usr/bin/env python3
"""Test Suite for APDU4J Integration with GREENWIRE.

Comprehensive testing of APDU4J command structures, GlobalPlatform commands,
and integration with GREENWIRE's existing smartcard infrastructure.
"""

import logging, os, sys, unittest
from unittest.mock import Mock, patch  # noqa: F401

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from apdu4j_data.apdu_commands import (
    APDU4JCommand, APDU4JInterface, APDU_COMMANDS, PCSC_COMMANDS,
    create_select_aid_command, create_pin_verify_command, create_get_data_command,
    parse_apdu_response, SW_SUCCESS, APDU_CASE_1, APDU_CASE_2S, APDU_CASE_4S
)
from apdu4j_data.gp_commands import GPCommand, GPManager, GP_COMMANDS  # noqa: F401
from apdu4j_data.apdu4j_integration import GREENWIREAPDU4JInterface, create_apdu4j_interface  # noqa: F401

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TestAPDU4JCommand(unittest.TestCase):
    """Test APDU4J command structure and encoding."""
    
    def test_case_1_apdu(self):
        """Test Case 1 APDU (no data, no response)."""
        cmd = APDU4JCommand(0x00, 0xA4, 0x00, 0x0C)
        
        self.assertEqual(cmd.case, APDU_CASE_1)
        self.assertEqual(cmd.to_hex(), "00A4000C")
        self.assertEqual(len(cmd.to_bytes()), 4)
        
    def test_case_2s_apdu(self):
        """Test Case 2S APDU (no data, short Le)."""
        cmd = APDU4JCommand(0x00, 0xCA, 0x00, 0x00, le=256)
        
        self.assertEqual(cmd.case, APDU_CASE_2S)
        self.assertEqual(cmd.to_hex(), "00CA000000")  # Le=256 encoded as 00
        self.assertEqual(len(cmd.to_bytes()), 5)
        
    def test_case_4s_apdu(self):
        """Test Case 4S APDU (short data, short Le)."""
        pin_data = b"1234"
        cmd = APDU4JCommand(0x00, 0x20, 0x00, 0x80, pin_data, le=256)
        
        self.assertEqual(cmd.case, APDU_CASE_4S)
(dry-run)

Changes for .\apdu_communicator.py:
--- original excerpt ---
#!/usr/bin/env python3
"""APDU Communication Module for GREENWIRE.

Provides PC/SC and NFC communication capabilities for APDU commands.
"""

import sys
import time
from typing import Optional, List, Dict, Any, Tuple

try:
    import smartcard
    from smartcard.System import readers
    from smartcard.util import toHexString, toBytes
    from smartcard.CardConnection import CardConnection
    from smartcard.Exceptions import CardConnectionException, NoCardException
    HAS_PYSCARD = True
except ImportError:
    HAS_PYSCARD = False

try:
    import nfc
    HAS_NFC = True
except ImportError:
    HAS_NFC = False


class APDUCommunicator:
    """High-level APDU communication interface supporting PC/SC and NFC."""
    
    def __init__(self, verbose: bool = False):
        """Initialize APDU communicator.
        
        Args:
            verbose: Enable verbose logging of APDU exchanges
        """
        self.verbose = verbose
        self.connection = None
        self.reader_name = None
        
    def list_readers(self) -> List[str]:
        """List available PC/SC readers.
        
        Returns:
            List of reader names
        """
        if not HAS_PYSCARD:
            return []
            
        try:
--- proposed excerpt ---
#!/usr/bin/env python3
"""APDU Communication Module for GREENWIRE.

Provides PC/SC and NFC communication capabilities for APDU commands.
"""

import sys, time  # noqa: F401
from typing import Any, Dict, List, Optional, Tuple

try:
    import smartcard
    from smartcard.System import readers
    from smartcard.util import toHexString, toBytes
    from smartcard.CardConnection import CardConnection
    from smartcard.Exceptions import CardConnectionException, NoCardException
    HAS_PYSCARD = True
except ImportError:
    HAS_PYSCARD = False

try:
    import nfc
    HAS_NFC = True
except ImportError:
    HAS_NFC = False


class APDUCommunicator:
    """High-level APDU communication interface supporting PC/SC and NFC."""
    
    def __init__(self, verbose: bool = False):
        """Initialize APDU communicator.
        
        Args:
            verbose: Enable verbose logging of APDU exchanges
        """
        self.verbose = verbose
        self.connection = None
        self.reader_name = None
        
    def list_readers(self) -> List[str]:
        """List available PC/SC readers.
        
        Returns:
            List of reader names
        """
        if not HAS_PYSCARD:
            return []
            
        try:
            reader_list = readers()
(dry-run)

Changes for .\applets\emv_vulntests\generate_apdu_tests.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
EMV Vulnerability Testing Suite - APDU Command Generator

This script generates comprehensive APDU command sequences for testing
merchant terminals with the EMV vulnerability testing applets.

Usage:
    python generate_apdu_tests.py [options]

For authorized security testing only.
"""

import json
from typing import Dict, List, Tuple
from dataclasses import dataclass
from enum import Enum

class VulnMode(Enum):
    """Vulnerability test modes"""
    NORMAL = 0x00
    EXPLOIT_1 = 0x01
    EXPLOIT_2 = 0x02
    EXPLOIT_3 = 0x03
    EXPLOIT_4 = 0x04
    EXPLOIT_5 = 0x05

@dataclass
class AppletInfo:
    """Information about a vulnerability testing applet"""
    name: str
    aid: str
    description: str
    test_modes: Dict[int, str]

class ApduTestGenerator:
    """Generates APDU test sequences for EMV vulnerability testing"""
    
    def __init__(self):
        self.applets = {
            'CVVBypassTester': AppletInfo(
                name='CVVBypassTester',
                aid='A0000000047080',
                description='Tests CVV/CVC validation bypass vulnerabilities',
                test_modes={
                    0x00: 'Normal CVV processing',
                    0x01: 'Return success for any CVV',
                    0x02: 'Manipulate CVM list to bypass CVV',
                    0x03: 'Invalid CVC3 generation',
                    0x04: 'CVV not checked response'
--- proposed excerpt ---
#!/usr/bin/env python3
"""
EMV Vulnerability Testing Suite - APDU Command Generator

This script generates comprehensive APDU command sequences for testing
merchant terminals with the EMV vulnerability testing applets.

Usage:
    python generate_apdu_tests.py [options]

For authorized security testing only.
"""

import json
from typing import Dict, List, Tuple  # noqa: F401
from dataclasses import dataclass
from enum import Enum

class VulnMode(Enum):
    """Vulnerability test modes"""
    NORMAL = 0x00
    EXPLOIT_1 = 0x01
    EXPLOIT_2 = 0x02
    EXPLOIT_3 = 0x03
    EXPLOIT_4 = 0x04
    EXPLOIT_5 = 0x05

@dataclass
class AppletInfo:
    """Information about a vulnerability testing applet"""
    name: str
    aid: str
    description: str
    test_modes: Dict[int, str]

class ApduTestGenerator:
    """Generates APDU test sequences for EMV vulnerability testing"""
    
    def __init__(self):
        self.applets = {
            'CVVBypassTester': AppletInfo(
                name='CVVBypassTester',
                aid='A0000000047080',
                description='Tests CVV/CVC validation bypass vulnerabilities',
                test_modes={
                    0x00: 'Normal CVV processing',
                    0x01: 'Return success for any CVV',
                    0x02: 'Manipulate CVM list to bypass CVV',
                    0x03: 'Invalid CVC3 generation',
                    0x04: 'CVV not checked response'
(dry-run)

Changes for .\cli\__init__.py:
--- original excerpt ---
"""
GREENWIRE CLI Module
Handles command line interface components.
"""

from cli.argument_parser import create_argument_parser
from cli.command_router import CommandRouter

__all__ = ['create_argument_parser', 'CommandRouter']
--- proposed excerpt ---
"""
GREENWIRE CLI Module
Handles command line interface components.
"""

from cli.argument_parser import create_argument_parser  # noqa: F401
from cli.command_router import CommandRouter  # noqa: F401

__all__ = ['create_argument_parser', 'CommandRouter']
(dry-run)

Changes for .\cli\argument_parser.py:
--- original excerpt ---
"""
GREENWIRE Argument Parser
Handles all CLI argument parsing and subcommand definitions.
"""

import argparse
from typing import Any
from core.logging_system import get_logger

def create_argument_parser() -> argparse.ArgumentParser:
    """Create the main argument parser with all subcommands."""
    
    logger = get_logger()
    
    parser = argparse.ArgumentParser(
        description="GREENWIRE - EMV/NFC/JavaCard Security Testing Framework",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python greenwire.py testing fuzz --hardware
  python greenwire.py easycard generate random --count 5
  python greenwire.py emulator --profile nfc --hardware
  python greenwire.py install-cap myapplet.cap
        """
    )
    
    # Global arguments
    parser.add_argument("--version", action="version", version="GREENWIRE 2.0")
    parser.add_argument("--production", action="store_true", 
                       help="Run in production mode (reduced logging)")
    parser.add_argument("--menu", action="store_true", 
                       help="Launch interactive menu interface")
    parser.add_argument("--verbose", "-v", action="store_true", 
                       help="Enable verbose output")
    parser.add_argument("--config", type=str, 
                       help="Path to configuration file")
    
    # Create subparsers
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Testing subcommand
    _add_testing_parser(subparsers)
    
    # EasyCard subcommand  
    _add_easycard_parser(subparsers)
    
    # Emulation subcommand
    _add_emulation_parser(subparsers)
    
    # NFC subcommand
--- proposed excerpt ---
"""
GREENWIRE Argument Parser
Handles all CLI argument parsing and subcommand definitions.
"""

import argparse
from typing import Any  # noqa: F401
from core.logging_system import get_logger

def create_argument_parser() -> argparse.ArgumentParser:
    """Create the main argument parser with all subcommands."""
    
    logger = get_logger()
    
    parser = argparse.ArgumentParser(
        description="GREENWIRE - EMV/NFC/JavaCard Security Testing Framework",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python greenwire.py testing fuzz --hardware
  python greenwire.py easycard generate random --count 5
  python greenwire.py emulator --profile nfc --hardware
  python greenwire.py install-cap myapplet.cap
        """
    )
    
    # Global arguments
    parser.add_argument("--version", action="version", version="GREENWIRE 2.0")
    parser.add_argument("--production", action="store_true", 
                       help="Run in production mode (reduced logging)")
    parser.add_argument("--menu", action="store_true", 
                       help="Launch interactive menu interface")
    parser.add_argument("--verbose", "-v", action="store_true", 
                       help="Enable verbose output")
    parser.add_argument("--config", type=str, 
                       help="Path to configuration file")
    
    # Create subparsers
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Testing subcommand
    _add_testing_parser(subparsers)
    
    # EasyCard subcommand  
    _add_easycard_parser(subparsers)
    
    # Emulation subcommand
    _add_emulation_parser(subparsers)
    
    # NFC subcommand
(dry-run)

Changes for .\cli\command_router.py:
--- original excerpt ---
"""
GREENWIRE Command Router
Routes parsed CLI arguments to appropriate handlers.
"""

import sys
from typing import Any, Dict, Optional
from core.logging_system import get_logger, handle_errors
from core.config import get_config
from core.greenwire_bridge import get_bridge

class CommandRouter:
    """Routes CLI commands to appropriate handlers."""
    
    def __init__(self):
        self.logger = get_logger()
        self.config = get_config()
        self.bridge = get_bridge()
        self._handlers = {}
        
    def register_handler(self, command: str, handler_func):
        """Register a command handler function."""
        self._handlers[command] = handler_func
        self.logger.debug(f"Registered handler for command: {command}")
    
    @handle_errors("Command routing", return_on_error=False)
    def route_command(self, args: Any) -> bool:
        """
        Route parsed arguments to appropriate handler.
        
        Args:
            args: Parsed arguments from argparse
            
        Returns:
            True if command executed successfully
        """
        if not hasattr(args, 'command') or not args.command:
            self.logger.error("No command specified")
            return False
        
        command = args.command
        
        # Handle special cases first
        if args.menu:
            return self._handle_menu_mode(args)
        
        # Route to specific command handlers
        if command == "testing":
            return self._handle_testing_command(args)
        elif command == "easycard":
--- proposed excerpt ---
"""
GREENWIRE Command Router
Routes parsed CLI arguments to appropriate handlers.
"""

import sys  # noqa: F401
from typing import Any, Dict, Optional  # noqa: F401
from core.logging_system import get_logger, handle_errors
from core.config import get_config
from core.greenwire_bridge import get_bridge

class CommandRouter:
    """Routes CLI commands to appropriate handlers."""
    
    def __init__(self):
        self.logger = get_logger()
        self.config = get_config()
        self.bridge = get_bridge()
        self._handlers = {}
        
    def register_handler(self, command: str, handler_func):
        """Register a command handler function."""
        self._handlers[command] = handler_func
        self.logger.debug(f"Registered handler for command: {command}")
    
    @handle_errors("Command routing", return_on_error=False)
    def route_command(self, args: Any) -> bool:
        """
        Route parsed arguments to appropriate handler.
        
        Args:
            args: Parsed arguments from argparse
            
        Returns:
            True if command executed successfully
        """
        if not hasattr(args, 'command') or not args.command:
            self.logger.error("No command specified")
            return False
        
        command = args.command
        
        # Handle special cases first
        if args.menu:
            return self._handle_menu_mode(args)
        
        # Route to specific command handlers
        if command == "testing":
            return self._handle_testing_command(args)
        elif command == "easycard":
(dry-run)

Changes for .\core\advanced_fuzzing.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
Advanced Fuzzing Module for GREENWIRE
Focuses on memory extraction, hidden data discovery, and key recovery
"""

import os
import sys
import time
import random
import hashlib
import struct
import math
import logging
from typing import List, Dict, Tuple, Optional, Any
from datetime import datetime
from collections import defaultdict, Counter

try:
    from smartcard.System import readers
    from smartcard.util import toHexString, toBytes
    from smartcard.CardConnection import CardConnection
    from smartcard.Exceptions import CardConnectionException
    PYSCARD_AVAILABLE = True
except ImportError:
    PYSCARD_AVAILABLE = False

class MemoryExtractionFuzzer:
    def _attempt_memory_read(self, addr: int, length: int, method: str = "default") -> bytes:
        """
        Attempt to read memory from the card at the given address using the specified method.
        Returns the data as bytes, or empty bytes on failure.
        """
        self.log_verbose(f"[MEMORY_READ] Attempting to read {length} bytes at 0x{addr:04X} using method '{method}'", level='debug')
        # This is a stub implementation. In a real scenario, this would send APDUs to the card.
        # For now, simulate with random data or error if not connected.
        if not hasattr(self, 'card_connected') or not self.card_connected:
            self.log_verbose("[MEMORY_READ] No card connected. Returning empty bytes.", level='error')
            return b''
        # Simulate memory read (replace with real APDU logic)
        import os
        return os.urandom(length)
    """Enhanced fuzzing with GitHub research improvements for memory extraction and hidden data discovery"""
    
    def __init__(self, verbose=True, enable_logging=True):
        self.connection = None
        self.reader = None
        self.discovered_data = {}
        self.memory_map = {}
        self.extracted_keys = []
--- proposed excerpt ---
#!/usr/bin/env python3
"""
Advanced Fuzzing Module for GREENWIRE
Focuses on memory extraction, hidden data discovery, and key recovery
"""

import hashlib, logging, math, os, random, struct, sys, time  # noqa: F401
from typing import Any, Dict, List, Optional, Tuple  # noqa: F401
from datetime import datetime
from collections import Counter, defaultdict

try:
    from smartcard.System import readers
    from smartcard.util import toHexString, toBytes
    from smartcard.CardConnection import CardConnection
    from smartcard.Exceptions import CardConnectionException
    PYSCARD_AVAILABLE = True
except ImportError:
    PYSCARD_AVAILABLE = False

class MemoryExtractionFuzzer:
    def _attempt_memory_read(self, addr: int, length: int, method: str = "default") -> bytes:
        """
        Attempt to read memory from the card at the given address using the specified method.
        Returns the data as bytes, or empty bytes on failure.
        """
        self.log_verbose(f"[MEMORY_READ] Attempting to read {length} bytes at 0x{addr:04X} using method '{method}'", level='debug')
        # This is a stub implementation. In a real scenario, this would send APDUs to the card.
        # For now, simulate with random data or error if not connected.
        if not hasattr(self, 'card_connected') or not self.card_connected:
            self.log_verbose("[MEMORY_READ] No card connected. Returning empty bytes.", level='error')
            return b''
        # Simulate memory read (replace with real APDU logic)
        import os
        return os.urandom(length)
    """Enhanced fuzzing with GitHub research improvements for memory extraction and hidden data discovery"""
    
    def __init__(self, verbose=True, enable_logging=True):
        self.connection = None
        self.reader = None
        self.discovered_data = {}
        self.memory_map = {}
        self.extracted_keys = []
        self.verbose = verbose
        self.enable_logging = enable_logging
        self.coverage_bitmap = defaultdict(int)
        self.prefix_discoveries = {}
        self.emv_specific_data = {}
        self.afl_style_traces = []
        
(dry-run)

Changes for .\core\ai_vuln_testing.py:
--- original excerpt ---
#!/usr/bin/env python3
"""AI Vulnerability (Heuristic APDU) Testing Engine

Generates mutated APDUs from a seed corpus, optionally executes them
against a smartcard via PC/SC or an Android relay channel, and collects
latency / response metrics plus anomaly heuristics.

Safe to run in dry-run mode; avoid use against production cards.
"""
from __future__ import annotations
import time, json, random, statistics, os
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional

DEFAULT_SEED_CORPUS = [
    "00A4040007A0000002471001",  # PPSE / AID select
    "00A4040007A0000000031010",  # MasterCard AID
    "00A4040007A0000000041010",  # Visa AID
    "80CA9F1700",                 # GET DATA
]

HEX_CHARS = "0123456789ABCDEF"

@dataclass
class MutationResult:
    apdu: str
    strategy: str
    response_sw: Optional[str] = None
    response_len: Optional[int] = None
    roundtrip_ms: Optional[int] = None
    status: str = "generated"  # generated | executed | timeout | error
    anomaly_flags: List[str] = field(default_factory=list)

@dataclass
class AIVulnRunResult:
    started_at: float
    finished_at: float
    duration_ms: int
    params: Dict[str, Any]
    mutations: List[MutationResult]
    stats: Dict[str, Any]
    anomalies: List[Dict[str, Any]]

class AIVulnTester:
    def __init__(self, use_pcsc: bool=False, use_android: bool=False, timeout_ms: int=1200):
        self.use_pcsc = use_pcsc
        self.use_android = use_android
        self.timeout_ms = timeout_ms
        self.pcsc_channel = None
        self.android_channel = None
--- proposed excerpt ---
#!/usr/bin/env python3
"""AI Vulnerability (Heuristic APDU) Testing Engine

Generates mutated APDUs from a seed corpus, optionally executes them
against a smartcard via PC/SC or an Android relay channel, and collects
latency / response metrics plus anomaly heuristics.

Safe to run in dry-run mode; avoid use against production cards.
"""
from __future__ import annotations  # noqa: F401
import json, os, random, statistics, time  # noqa: F401
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

DEFAULT_SEED_CORPUS = [
    "00A4040007A0000002471001",  # PPSE / AID select
    "00A4040007A0000000031010",  # MasterCard AID
    "00A4040007A0000000041010",  # Visa AID
    "80CA9F1700",                 # GET DATA
]

HEX_CHARS = "0123456789ABCDEF"

@dataclass
class MutationResult:
    apdu: str
    strategy: str
    response_sw: Optional[str] = None
    response_len: Optional[int] = None
    roundtrip_ms: Optional[int] = None
    status: str = "generated"  # generated | executed | timeout | error
    anomaly_flags: List[str] = field(default_factory=list)

@dataclass
class AIVulnRunResult:
    started_at: float
    finished_at: float
    duration_ms: int
    params: Dict[str, Any]
    mutations: List[MutationResult]
    stats: Dict[str, Any]
    anomalies: List[Dict[str, Any]]

class AIVulnTester:
    def __init__(self, use_pcsc: bool=False, use_android: bool=False, timeout_ms: int=1200):
        self.use_pcsc = use_pcsc
        self.use_android = use_android
        self.timeout_ms = timeout_ms
        self.pcsc_channel = None
        self.android_channel = None
(dry-run)

Changes for .\core\android_manager.py:
--- original excerpt ---
"""
GREENWIRE Android/ADB Integration Manager
Handles Android device management, ADB command execution, and NFC enablement.
"""

import subprocess
import threading
import time
import json
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any

from .logging_system import get_logger, handle_errors
from .config import get_config

class AndroidManager:
    """Manages Android device interactions via ADB."""
    
    def __init__(self):
        self.logger = get_logger()
        self.config = get_config()
        self.adb_cache = {}
        self.cache_timeout = 30  # seconds
        self.device_monitoring_active = False
        self.monitoring_thread = None
        self.nfc_listeners = {}
        
    @handle_errors("ADB command execution", return_on_error="")
    def adb_cmd(self, cmd: str, device_id: Optional[str] = None, timeout: int = 10) -> str:
        """
        Execute ADB command with caching and restart logic.
        
        Args:
            cmd: ADB command to execute
            device_id: Specific device ID (optional)
            timeout: Command timeout in seconds
            
        Returns:
            Command output as string
        """
        # Create cache key
        cache_key = f"{device_id or 'default'}:{cmd}"
        current_time = datetime.now()
        
        # Check cache for recent results
        if cache_key in self.adb_cache:
            cached_result, cached_time = self.adb_cache[cache_key]
            if current_time - cached_time < timedelta(seconds=self.cache_timeout):
                self.logger.debug(f"Using cached ADB result for: {cmd}")
--- proposed excerpt ---
"""
GREENWIRE Android/ADB Integration Manager
Handles Android device management, ADB command execution, and NFC enablement.
"""

import json, os, subprocess, threading, time  # noqa: F401
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Tuple  # noqa: F401

from .logging_system import get_logger, handle_errors
from .config import get_config

class AndroidManager:
    """Manages Android device interactions via ADB."""
    
    def __init__(self):
        self.logger = get_logger()
        self.config = get_config()
        self.adb_cache = {}
        self.cache_timeout = 30  # seconds
        self.device_monitoring_active = False
        self.monitoring_thread = None
        self.nfc_listeners = {}
        
    @handle_errors("ADB command execution", return_on_error="")
    def adb_cmd(self, cmd: str, device_id: Optional[str] = None, timeout: int = 10) -> str:
        """
        Execute ADB command with caching and restart logic.
        
        Args:
            cmd: ADB command to execute
            device_id: Specific device ID (optional)
            timeout: Command timeout in seconds
            
        Returns:
            Command output as string
        """
        # Create cache key
        cache_key = f"{device_id or 'default'}:{cmd}"
        current_time = datetime.now()
        
        # Check cache for recent results
        if cache_key in self.adb_cache:
            cached_result, cached_time = self.adb_cache[cache_key]
            if current_time - cached_time < timedelta(seconds=self.cache_timeout):
                self.logger.debug(f"Using cached ADB result for: {cmd}")
                return cached_result
        
        # Build ADB command
        adb_command = ["adb"]
(dry-run)

Changes for .\core\apdu_fuzzer.py:
--- original excerpt ---
#!/usr/bin/env python3
"""Native APDU Fuzzer (modularized).

Provides simulation-based and (optional) real smartcard fuzzing of APDU
commands for JCOP, NXP and EMV cards. Extracted from the monolithic
`greenwire.py` so other modules (menus/tests) can import without creating
heavy CLI side‑effects.

Key design goals:
 - Minimal external deps (only uses pyscard if available and requested)
 - Deterministic structure but randomized mutations
 - Simple contract: run_native_apdu_fuzz(...) returns (session_data, report_path)
 - Safe hardware mode (skips oversize payloads, catches all transmit errors)
"""

from __future__ import annotations

import os
import random
import time
from pathlib import Path
from typing import Dict, Any, List, Optional


class NativeAPDUFuzzer:
    """Core APDU fuzzing engine.

    If a `send_apdu_callable` is supplied it will be used to transmit real
    APDUs (hex string). Otherwise responses are simulated.
    """

    def __init__(self, verbose: bool = True, send_apdu_callable=None, hw_max_payload: int = 220):
        self.verbose = verbose
        self.send_apdu = send_apdu_callable  # function(hex_str)-> (data_hex, sw1, sw2) or raises
        self.hw_max_payload = hw_max_payload
        self.session_data: Dict[str, Any] = {
            "commands_sent": 0,
            "responses_received": 0,
            "vulnerabilities": [],
            "errors": [],
            "start_time": None,
            "end_time": None,
            "response_times_ms": [],  # flat list
            "hardware_mode": bool(send_apdu_callable),
        }
        self.card_commands = {
            "jcop": self._get_jcop_commands(),
            "nxp": self._get_nxp_commands(),
            "emv": self._get_emv_commands(),
        }
--- proposed excerpt ---
#!/usr/bin/env python3
"""Native APDU Fuzzer (modularized).

Provides simulation-based and (optional) real smartcard fuzzing of APDU
commands for JCOP, NXP and EMV cards. Extracted from the monolithic
`greenwire.py` so other modules (menus/tests) can import without creating
heavy CLI side‑effects.

Key design goals:
 - Minimal external deps (only uses pyscard if available and requested)
 - Deterministic structure but randomized mutations
 - Simple contract: run_native_apdu_fuzz(...) returns (session_data, report_path)
 - Safe hardware mode (skips oversize payloads, catches all transmit errors)
"""

from __future__ import annotations  # noqa: F401

import os, random, time
from pathlib import Path
from typing import Any, Dict, List, Optional


class NativeAPDUFuzzer:
    """Core APDU fuzzing engine.

    If a `send_apdu_callable` is supplied it will be used to transmit real
    APDUs (hex string). Otherwise responses are simulated.
    """

    def __init__(self, verbose: bool = True, send_apdu_callable=None, hw_max_payload: int = 220):
        self.verbose = verbose
        self.send_apdu = send_apdu_callable  # function(hex_str)-> (data_hex, sw1, sw2) or raises
        self.hw_max_payload = hw_max_payload
        self.session_data: Dict[str, Any] = {
            "commands_sent": 0,
            "responses_received": 0,
            "vulnerabilities": [],
            "errors": [],
            "start_time": None,
            "end_time": None,
            "response_times_ms": [],  # flat list
            "hardware_mode": bool(send_apdu_callable),
        }
        self.card_commands = {
            "jcop": self._get_jcop_commands(),
            "nxp": self._get_nxp_commands(),
            "emv": self._get_emv_commands(),
        }

    # --- Base command sets -------------------------------------------------
(dry-run)

Changes for .\core\cap_manager.py:
--- original excerpt ---
"""
GREENWIRE CAP File Manager
Handles JavaCard CAP file operations, validation, and installation.
"""

import os
import subprocess
import json
from typing import Dict, List, Optional, Any, Union
from .logging_system import get_logger, handle_errors
from .config import get_config

class CAPFileManager:
    """Manages JavaCard CAP file operations."""
    
    def __init__(self):
        self.logger = get_logger()
        self.config = get_config()
        self.valid_extensions = {'.cap', '.CAP'}
        self.aid_cache = {}
        self.default_android_key = "404142434445464748494A4B4C4D4E4F"  # Default Android HCE key
    
    @handle_errors("CAP file validation", return_on_error=False)
    def validate_cap_file(self, file_path: str) -> bool:
        """
        Validate CAP file format and structure.
        
        Args:
            file_path: Path to CAP file
            
        Returns:
            True if valid, False otherwise
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"CAP file not found: {file_path}")

        if not any(file_path.endswith(ext) for ext in self.valid_extensions):
            raise ValueError(f"Invalid file extension. Expected {self.valid_extensions}")

        # Validate CAP file structure
        try:
            with open(file_path, 'rb') as f:
                header = f.read(4)
                if header != b'\xDE\xCA\xFF\xED':  # JavaCard CAP file magic number
                    raise ValueError("Invalid CAP file format")

                # Extract and cache AID information
                f.seek(0)
                self._extract_aid_info(f, file_path)
                
--- proposed excerpt ---
"""
GREENWIRE CAP File Manager
Handles JavaCard CAP file operations, validation, and installation.
"""

import json, os, subprocess
from typing import Any, Dict, List, Optional, Union  # noqa: F401
from .logging_system import get_logger, handle_errors
from .config import get_config

class CAPFileManager:
    """Manages JavaCard CAP file operations."""
    
    def __init__(self):
        self.logger = get_logger()
        self.config = get_config()
        self.valid_extensions = {'.cap', '.CAP'}
        self.aid_cache = {}
        self.default_android_key = "404142434445464748494A4B4C4D4E4F"  # Default Android HCE key
    
    @handle_errors("CAP file validation", return_on_error=False)
    def validate_cap_file(self, file_path: str) -> bool:
        """
        Validate CAP file format and structure.
        
        Args:
            file_path: Path to CAP file
            
        Returns:
            True if valid, False otherwise
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"CAP file not found: {file_path}")

        if not any(file_path.endswith(ext) for ext in self.valid_extensions):
            raise ValueError(f"Invalid file extension. Expected {self.valid_extensions}")

        # Validate CAP file structure
        try:
            with open(file_path, 'rb') as f:
                header = f.read(4)
                if header != b'\xDE\xCA\xFF\xED':  # JavaCard CAP file magic number
                    raise ValueError("Invalid CAP file format")

                # Extract and cache AID information
                f.seek(0)
                self._extract_aid_info(f, file_path)
                
            return True
            
(dry-run)

Changes for .\core\card_standards.py:
--- original excerpt ---
#!/usr/bin/env python3
"""Smartcard standards profile definitions for GREENWIRE.
Provides lightweight data-only profiles for generating test cards across common platforms.
"""
from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Dict, Any
import random
import secrets

@dataclass
class CardProfile:
    name: str
    standard: str
    atref: str
    historical_bytes: str
    aid_list: List[str]
    description: str
    capabilities: List[str]
    kcv: str | None = None
    keys: Dict[str, str] = field(default_factory=dict)
    extra: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "standard": self.standard,
            "atr": self.atref,
            "historical_bytes": self.historical_bytes,
            "aids": self.aid_list,
            "description": self.description,
            "capabilities": self.capabilities,
            "kcv": self.kcv,
            "keys": self.keys,
            "extra": self.extra,
        }

def _rand_pan(iin: str = "535522") -> str:
    body = iin + ''.join(str(random.randint(0,9)) for _ in range(9))
    # Luhn
    digits = [int(c) for c in body]
    for i in range(len(digits)-1, -1, -2):
        digits[i] *= 2
        if digits[i] > 9:
            digits[i] -= 9
    check = (10 - (sum(digits) % 10)) % 10
    return body + str(check)

def _gen_key(size_bytes: int) -> str:
    return secrets.token_hex(size_bytes)
--- proposed excerpt ---
#!/usr/bin/env python3
"""Smartcard standards profile definitions for GREENWIRE.
Provides lightweight data-only profiles for generating test cards across common platforms.
"""
from __future__ import annotations  # noqa: F401
from dataclasses import dataclass, field
from typing import Any, Dict, List
import random, secrets

@dataclass
class CardProfile:
    name: str
    standard: str
    atref: str
    historical_bytes: str
    aid_list: List[str]
    description: str
    capabilities: List[str]
    kcv: str | None = None
    keys: Dict[str, str] = field(default_factory=dict)
    extra: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "standard": self.standard,
            "atr": self.atref,
            "historical_bytes": self.historical_bytes,
            "aids": self.aid_list,
            "description": self.description,
            "capabilities": self.capabilities,
            "kcv": self.kcv,
            "keys": self.keys,
            "extra": self.extra,
        }

def _rand_pan(iin: str = "535522") -> str:
    body = iin + ''.join(str(random.randint(0,9)) for _ in range(9))
    # Luhn
    digits = [int(c) for c in body]
    for i in range(len(digits)-1, -1, -2):
        digits[i] *= 2
        if digits[i] > 9:
            digits[i] -= 9
    check = (10 - (sum(digits) % 10)) % 10
    return body + str(check)

def _gen_key(size_bytes: int) -> str:
    return secrets.token_hex(size_bytes)

(dry-run)

Changes for .\core\config.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Core Configuration System
Centralized configuration management for all GREENWIRE operations
"""

import os
import json
import logging
from dataclasses import dataclass, asdict
from typing import Optional, List, Dict, Any
from pathlib import Path

@dataclass
class AppConfig:
    """Application configuration settings."""
    name: str = "GREENWIRE"
    version: str = "3.0"
    description: str = "Advanced Payment Card Security Suite"
    environment: str = "development"
    static_mode: bool = False

@dataclass
class LoggingConfig:
    """Logging configuration settings."""
    level: str = "INFO"
    format: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    file: Optional[str] = None
    console: bool = True

@dataclass
class NFCConfig:
    """NFC-specific configuration settings."""
    use_android: bool = True
    use_hardware: bool = True
    timeout: int = 30
    retry_attempts: int = 3
    protocol: str = "all"
    continuous_scan: bool = False
    adb_path: Optional[str] = None

@dataclass
class MenuConfig:
    """Menu system configuration."""
    structure: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.structure is None:
            self.structure = {}

--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Core Configuration System
Centralized configuration management for all GREENWIRE operations
"""

import json, logging, os
from dataclasses import asdict, dataclass
from typing import Any, Dict, List, Optional
from pathlib import Path  # noqa: F401

@dataclass
class AppConfig:
    """Application configuration settings."""
    name: str = "GREENWIRE"
    version: str = "3.0"
    description: str = "Advanced Payment Card Security Suite"
    environment: str = "development"
    static_mode: bool = False

@dataclass
class LoggingConfig:
    """Logging configuration settings."""
    level: str = "INFO"
    format: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    file: Optional[str] = None
    console: bool = True

@dataclass
class NFCConfig:
    """NFC-specific configuration settings."""
    use_android: bool = True
    use_hardware: bool = True
    timeout: int = 30
    retry_attempts: int = 3
    protocol: str = "all"
    continuous_scan: bool = False
    adb_path: Optional[str] = None

@dataclass
class MenuConfig:
    """Menu system configuration."""
    structure: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.structure is None:
            self.structure = {}

@dataclass
class SecurityConfig:
(dry-run)

Changes for .\core\emv_processor.py:
--- original excerpt ---
"""
GREENWIRE EMV Processor
Handles EMV TLV parsing, tag interpretation, and transaction data processing.
"""

from typing import Dict, List, Optional, Tuple, Any, Union
import os
from .logging_system import get_logger, handle_errors

class EMVProcessor:
    """Processes EMV transaction data and TLV structures."""
    
    def __init__(self):
        self.logger = get_logger()
        self.emv_tags = self._load_emv_tags()
    
    def _load_emv_tags(self) -> Dict[str, str]:
        """Load EMV tag definitions."""
        return {
            '4F': 'Application Identifier (AID)',
            '50': 'Application Label',
            '57': 'Track 2 Equivalent Data',
            '5A': 'Application Primary Account Number (PAN)',
            '5F20': 'Cardholder Name',
            '5F24': 'Application Expiration Date',
            '5F25': 'Application Effective Date',
            '5F28': 'Issuer Country Code',
            '5F2A': 'Transaction Currency Code',
            '5F2D': 'Language Preference',
            '5F30': 'Service Code',
            '5F34': 'Application Primary Account Number (PAN) Sequence Number',
            '82': 'Application Interchange Profile',
            '84': 'Dedicated File (DF) Name',
            '87': 'Application Priority Indicator',
            '88': 'Short File Identifier (SFI)',
            '8A': 'Authorization Response Code',
            '8C': 'Card Risk Management Data Object List 1 (CDOL1)',
            '8D': 'Card Risk Management Data Object List 2 (CDOL2)',
            '8E': 'Cardholder Verification Method (CVM) List',
            '8F': 'Certification Authority Public Key Index',
            '90': 'Issuer Public Key Certificate',
            '92': 'Issuer Public Key Remainder',
            '93': 'Signed Static Application Data',
            '94': 'Application File Locator (AFL)',
            '95': 'Terminal Verification Results',
            '9A': 'Transaction Date',
            '9B': 'Transaction Status Information',
            '9C': 'Transaction Type',
            '9F01': 'Acquirer Identifier',
            '9F02': 'Amount, Authorized (Numeric)',
--- proposed excerpt ---
"""
GREENWIRE EMV Processor
Handles EMV TLV parsing, tag interpretation, and transaction data processing.
"""

from typing import Any, Dict, List, Optional, Tuple, Union  # noqa: F401
import os
from .logging_system import get_logger, handle_errors

class EMVProcessor:
    """Processes EMV transaction data and TLV structures."""
    
    def __init__(self):
        self.logger = get_logger()
        self.emv_tags = self._load_emv_tags()
    
    def _load_emv_tags(self) -> Dict[str, str]:
        """Load EMV tag definitions."""
        return {
            '4F': 'Application Identifier (AID)',
            '50': 'Application Label',
            '57': 'Track 2 Equivalent Data',
            '5A': 'Application Primary Account Number (PAN)',
            '5F20': 'Cardholder Name',
            '5F24': 'Application Expiration Date',
            '5F25': 'Application Effective Date',
            '5F28': 'Issuer Country Code',
            '5F2A': 'Transaction Currency Code',
            '5F2D': 'Language Preference',
            '5F30': 'Service Code',
            '5F34': 'Application Primary Account Number (PAN) Sequence Number',
            '82': 'Application Interchange Profile',
            '84': 'Dedicated File (DF) Name',
            '87': 'Application Priority Indicator',
            '88': 'Short File Identifier (SFI)',
            '8A': 'Authorization Response Code',
            '8C': 'Card Risk Management Data Object List 1 (CDOL1)',
            '8D': 'Card Risk Management Data Object List 2 (CDOL2)',
            '8E': 'Cardholder Verification Method (CVM) List',
            '8F': 'Certification Authority Public Key Index',
            '90': 'Issuer Public Key Certificate',
            '92': 'Issuer Public Key Remainder',
            '93': 'Signed Static Application Data',
            '94': 'Application File Locator (AFL)',
            '95': 'Terminal Verification Results',
            '9A': 'Transaction Date',
            '9B': 'Transaction Status Information',
            '9C': 'Transaction Type',
            '9F01': 'Acquirer Identifier',
            '9F02': 'Amount, Authorized (Numeric)',
(dry-run)

Changes for .\core\global_defaults.py:
--- original excerpt ---
#!/usr/bin/env python3
"""Global defaults configuration for GREENWIRE.
Centralizes cross-feature runtime defaults accessible by menu and CLI.
"""
from __future__ import annotations
import json, os, threading
from pathlib import Path

_DEFAULTS = {
    "verbose_default": True,
    "max_payload_default": 220,
    "stateful_default": False,
    "artifact_dir_default": ".",
}

_LOCK = threading.Lock()
_CONFIG_PATH = Path(__file__).resolve().parent.parent / "global_defaults.json"


def _ensure_file():
    if not _CONFIG_PATH.exists():
        save_defaults(_DEFAULTS)


def load_defaults() -> dict:
    _ensure_file()
    try:
        with _LOCK, open(_CONFIG_PATH, 'r', encoding='utf-8') as f:
            data = json.load(f)
        # Merge with defaults to fill missing keys
        merged = {**_DEFAULTS, **data}
        return merged
    except Exception:
        return dict(_DEFAULTS)


def save_defaults(new_values: dict):
    merged = {**_DEFAULTS, **new_values}
    with _LOCK:
        with open(_CONFIG_PATH, 'w', encoding='utf-8') as f:
            json.dump(merged, f, indent=2)
    return merged


def update_defaults(**kwargs):
    current = load_defaults()
    current.update({k: v for k,v in kwargs.items() if k in _DEFAULTS})
    return save_defaults(current)

__all__ = ["load_defaults", "save_defaults", "update_defaults"]
--- proposed excerpt ---
#!/usr/bin/env python3
"""Global defaults configuration for GREENWIRE.
Centralizes cross-feature runtime defaults accessible by menu and CLI.
"""
from __future__ import annotations  # noqa: F401
import json, os, threading  # noqa: F401
from pathlib import Path

_DEFAULTS = {
    "verbose_default": True,
    "max_payload_default": 220,
    "stateful_default": False,
    "artifact_dir_default": ".",
}

_LOCK = threading.Lock()
_CONFIG_PATH = Path(__file__).resolve().parent.parent / "global_defaults.json"


def _ensure_file():
    if not _CONFIG_PATH.exists():
        save_defaults(_DEFAULTS)


def load_defaults() -> dict:
    _ensure_file()
    try:
        with _LOCK, open(_CONFIG_PATH, 'r', encoding='utf-8') as f:
            data = json.load(f)
        # Merge with defaults to fill missing keys
        merged = {**_DEFAULTS, **data}
        return merged
    except Exception:
        return dict(_DEFAULTS)


def save_defaults(new_values: dict):
    merged = {**_DEFAULTS, **new_values}
    with _LOCK:
        with open(_CONFIG_PATH, 'w', encoding='utf-8') as f:
            json.dump(merged, f, indent=2)
    return merged


def update_defaults(**kwargs):
    current = load_defaults()
    current.update({k: v for k,v in kwargs.items() if k in _DEFAULTS})
    return save_defaults(current)

__all__ = ["load_defaults", "save_defaults", "update_defaults"]
(dry-run)

Changes for .\core\greenwire_bridge.py:
--- original excerpt ---
"""
GREENWIRE Bridge Module
Connects modular architecture to original greenwire.py implementations.
"""

import sys
import os
from pathlib import Path
from typing import Any, Dict, Optional

# Add greenwire root to path for imports
greenwire_root = Path(__file__).parent.parent
sys.path.insert(0, str(greenwire_root))

from core.logging_system import get_logger, handle_errors

# Import original greenwire functions
try:
    # Import the original greenwire module
    import greenwire as original_greenwire
    
    # Import key functions from original implementation
    run_testing_original = getattr(original_greenwire, 'run_testing', None)
    run_easycard_original = getattr(original_greenwire, 'run_easycard', None)
    run_nfc_original = getattr(original_greenwire, 'run_nfc', None)
    run_emulation_original = getattr(original_greenwire, 'run_emulation', None)
    run_gp_original = getattr(original_greenwire, 'run_gp', None)
    run_probe_hardware_original = getattr(original_greenwire, 'run_probe_hardware', None)
    run_apdu_original = getattr(original_greenwire, 'run_apdu', None)
    run_fido_original = getattr(original_greenwire, 'run_fido', None)
    run_install_cap_original = getattr(original_greenwire, 'run_install_cap', None)
    run_crypto_original = getattr(original_greenwire, 'run_crypto', None)
    run_interactive_menu_original = getattr(original_greenwire, 'run_interactive_menu', None)
    
    # Import classes from original implementation
    NativeAPDUFuzzer = getattr(original_greenwire, 'NativeAPDUFuzzer', None)
    AndroidNFCVerifier = getattr(original_greenwire, 'AndroidNFCVerifier', None)
    CAPFileHandler = getattr(original_greenwire, 'CAPFileHandler', None)
    NFCDaemon = getattr(original_greenwire, 'NFCDaemon', None)
    
    BRIDGE_AVAILABLE = True
    
except ImportError as e:
    # If original greenwire can't be imported, provide stubs
    run_testing_original = None
    run_easycard_original = None
    run_nfc_original = None
    run_emulation_original = None
    run_gp_original = None
    run_probe_hardware_original = None
--- proposed excerpt ---
"""
GREENWIRE Bridge Module
Connects modular architecture to original greenwire.py implementations.
"""

import os, sys  # noqa: F401
from pathlib import Path
from typing import Any, Dict, Optional  # noqa: F401

# Add greenwire root to path for imports
greenwire_root = Path(__file__).parent.parent
sys.path.insert(0, str(greenwire_root))

from core.logging_system import get_logger, handle_errors

# Import original greenwire functions
try:
    # Import the original greenwire module
    import greenwire as original_greenwire
    
    # Import key functions from original implementation
    run_testing_original = getattr(original_greenwire, 'run_testing', None)
    run_easycard_original = getattr(original_greenwire, 'run_easycard', None)
    run_nfc_original = getattr(original_greenwire, 'run_nfc', None)
    run_emulation_original = getattr(original_greenwire, 'run_emulation', None)
    run_gp_original = getattr(original_greenwire, 'run_gp', None)
    run_probe_hardware_original = getattr(original_greenwire, 'run_probe_hardware', None)
    run_apdu_original = getattr(original_greenwire, 'run_apdu', None)
    run_fido_original = getattr(original_greenwire, 'run_fido', None)
    run_install_cap_original = getattr(original_greenwire, 'run_install_cap', None)
    run_crypto_original = getattr(original_greenwire, 'run_crypto', None)
    run_interactive_menu_original = getattr(original_greenwire, 'run_interactive_menu', None)
    
    # Import classes from original implementation
    NativeAPDUFuzzer = getattr(original_greenwire, 'NativeAPDUFuzzer', None)
    AndroidNFCVerifier = getattr(original_greenwire, 'AndroidNFCVerifier', None)
    CAPFileHandler = getattr(original_greenwire, 'CAPFileHandler', None)
    NFCDaemon = getattr(original_greenwire, 'NFCDaemon', None)
    
    BRIDGE_AVAILABLE = True
    
except ImportError as e:
    # If original greenwire can't be imported, provide stubs
    run_testing_original = None
    run_easycard_original = None
    run_nfc_original = None
    run_emulation_original = None
    run_gp_original = None
    run_probe_hardware_original = None
    run_apdu_original = None
(dry-run)

Changes for .\core\imports.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Import Management System
Centralized, simplified import handling with clear fallbacks
"""

import importlib
import sys
from typing import Dict, List, Optional, Any
from core.logging_system import get_logger, handle_errors

class ModuleManager:
    """Centralized module import and availability management."""
    
    def __init__(self):
        self.available_modules = {}
        self.failed_imports = {}
        self.logger = get_logger()
        
        # Core module mappings
        self.module_map = {
            # NFC/Hardware modules
            'nfc': ['pyscard', 'smartcard'],
            'android_nfc': ['subprocess'],  # Built-in, always available
            'nfc_emulation': ['pyscard'],
            
            # Card/EMV modules  
            'emv': ['cryptography', 'pycryptodome'],
            'smartcard_ops': ['pyscard', 'smartcard'],
            'cap_file': [],  # Custom implementation
            
            # Fuzzing modules
            'apdu_fuzzer': [],  # Custom implementation
            'file_fuzzer': ['pillow'],
            'protocol_fuzzer': ['scapy'],
            
            # Crypto modules
            'crypto': ['cryptography', 'pycryptodome'],
            'key_manager': ['cryptography'],
            
            # System modules
            'device_detection': ['pyudev'],  # Optional
            'process_manager': [],  # Built-in
        }
    
    @handle_errors("Module availability check", return_on_error=False)
    def check_module_availability(self, module_name: str) -> bool:
        """Check if a module and its dependencies are available."""
        if module_name in self.available_modules:
            return self.available_modules[module_name]
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Import Management System
Centralized, simplified import handling with clear fallbacks
"""

import importlib, sys  # noqa: F401
from typing import Any, Dict, List, Optional
from core.logging_system import get_logger, handle_errors

class ModuleManager:
    """Centralized module import and availability management."""
    
    def __init__(self):
        self.available_modules = {}
        self.failed_imports = {}
        self.logger = get_logger()
        
        # Core module mappings
        self.module_map = {
            # NFC/Hardware modules
            'nfc': ['pyscard', 'smartcard'],
            'android_nfc': ['subprocess'],  # Built-in, always available
            'nfc_emulation': ['pyscard'],
            
            # Card/EMV modules  
            'emv': ['cryptography', 'pycryptodome'],
            'smartcard_ops': ['pyscard', 'smartcard'],
            'cap_file': [],  # Custom implementation
            
            # Fuzzing modules
            'apdu_fuzzer': [],  # Custom implementation
            'file_fuzzer': ['pillow'],
            'protocol_fuzzer': ['scapy'],
            
            # Crypto modules
            'crypto': ['cryptography', 'pycryptodome'],
            'key_manager': ['cryptography'],
            
            # System modules
            'device_detection': ['pyudev'],  # Optional
            'process_manager': [],  # Built-in
        }
    
    @handle_errors("Module availability check", return_on_error=False)
    def check_module_availability(self, module_name: str) -> bool:
        """Check if a module and its dependencies are available."""
        if module_name in self.available_modules:
            return self.available_modules[module_name]
        
(dry-run)

Changes for .\core\logging_system.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Unified Logging and Error Handling System
Provides consistent logging, error handling, and operation tracking
"""

import logging
import sys
import traceback
from functools import wraps
from typing import Optional, Any, Callable
from pathlib import Path
from datetime import datetime

class GreenwireFormatter(logging.Formatter):
    """Custom formatter with color support and structured output."""
    
    # Color codes for different log levels
    COLORS = {
        'DEBUG': '\033[36m',    # Cyan
        'INFO': '\033[32m',     # Green  
        'WARNING': '\033[33m',  # Yellow
        'ERROR': '\033[31m',    # Red
        'CRITICAL': '\033[35m', # Magenta
        'RESET': '\033[0m'      # Reset
    }
    
    def format(self, record):
        # Add timestamp and level with colors
        if hasattr(record, 'operation'):
            log_format = f"{self.COLORS.get(record.levelname, '')}{record.levelname:<8}{self.COLORS['RESET']} " \
                        f"[{record.operation}] {record.getMessage()}"
        else:
            log_format = f"{self.COLORS.get(record.levelname, '')}{record.levelname:<8}{self.COLORS['RESET']} " \
                        f"{record.getMessage()}"
        
        # Add exception info if present
        if record.exc_info:
            log_format += f"\n{self.formatException(record.exc_info)}"
            
        return log_format

class GreenwireLogger:
    """Centralized logging system for GREENWIRE operations."""
    
    def __init__(self, name: str = "greenwire", log_file: Optional[str] = None, level: int = logging.INFO):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)
        
        # Clear existing handlers
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Unified Logging and Error Handling System
Provides consistent logging, error handling, and operation tracking
"""

import logging, sys, traceback  # noqa: F401
from functools import wraps
from typing import Any, Callable, Optional
from pathlib import Path
from datetime import datetime

class GreenwireFormatter(logging.Formatter):
    """Custom formatter with color support and structured output."""
    
    # Color codes for different log levels
    COLORS = {
        'DEBUG': '\033[36m',    # Cyan
        'INFO': '\033[32m',     # Green  
        'WARNING': '\033[33m',  # Yellow
        'ERROR': '\033[31m',    # Red
        'CRITICAL': '\033[35m', # Magenta
        'RESET': '\033[0m'      # Reset
    }
    
    def format(self, record):
        # Add timestamp and level with colors
        if hasattr(record, 'operation'):
            log_format = f"{self.COLORS.get(record.levelname, '')}{record.levelname:<8}{self.COLORS['RESET']} " \
                        f"[{record.operation}] {record.getMessage()}"
        else:
            log_format = f"{self.COLORS.get(record.levelname, '')}{record.levelname:<8}{self.COLORS['RESET']} " \
                        f"{record.getMessage()}"
        
        # Add exception info if present
        if record.exc_info:
            log_format += f"\n{self.formatException(record.exc_info)}"
            
        return log_format

class GreenwireLogger:
    """Centralized logging system for GREENWIRE operations."""
    
    def __init__(self, name: str = "greenwire", log_file: Optional[str] = None, level: int = logging.INFO):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)
        
        # Clear existing handlers
        self.logger.handlers.clear()
        
(dry-run)

Changes for .\core\menu_system.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Menu System
Configuration-driven menu system that consolidates and streamlines all menu operations
"""

import os
from typing import Dict, List, Callable, Any, Optional, Union
from dataclasses import dataclass, field
from enum import Enum
from core.config import get_config
from core.logging_system import get_logger, handle_errors
from core.imports import ModuleManager

# Prefer centralized MENU_ACTIONS registry for handlers to avoid fragile
# attribute introspection/import patterns. This ensures every menu entry maps
# cleanly to an implementation in one place (menu_handlers.py).
try:  # Local import relative to GREENWIRE root
    from menu_handlers import MENU_ACTIONS, handle_menu_action
except ImportError:  # Fallback if path issues arise – registry features disabled
    MENU_ACTIONS = {}
    def handle_menu_action(action_name: str, *args, **kwargs):  # type: ignore
        raise RuntimeError("MENU_ACTIONS registry unavailable – menu_handlers import failed")

# Menu item types
class MenuItemType(Enum):
    MENU = "menu"
    ACTION = "action" 
    SEPARATOR = "separator"
    SUBMENU = "submenu"

@dataclass
class MenuItem:
    """Configuration-driven menu item."""
    id: str
    title: str
    item_type: MenuItemType
    emoji: str = ""
    description: str = ""
    action: Optional[Callable] = None
    handler_module: Optional[str] = None
    handler_function: Optional[str] = None
    requirements: List[str] = field(default_factory=list)
    enabled: bool = True
    visible: bool = True
    children: List['MenuItem'] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

class MenuSystem:
    """Configuration-driven menu system."""
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Menu System
Configuration-driven menu system that consolidates and streamlines all menu operations
"""

import os
from typing import Any, Callable, Dict, List, Optional, Union  # noqa: F401
from dataclasses import dataclass, field
from enum import Enum
from core.config import get_config
from core.logging_system import get_logger, handle_errors
from core.imports import ModuleManager

# Prefer centralized MENU_ACTIONS registry for handlers to avoid fragile
# attribute introspection/import patterns. This ensures every menu entry maps
# cleanly to an implementation in one place (menu_handlers.py).
try:  # Local import relative to GREENWIRE root
    from menu_handlers import MENU_ACTIONS, handle_menu_action
except ImportError:  # Fallback if path issues arise – registry features disabled
    MENU_ACTIONS = {}
    def handle_menu_action(action_name: str, *args, **kwargs):  # type: ignore
        raise RuntimeError("MENU_ACTIONS registry unavailable – menu_handlers import failed")

# Menu item types
class MenuItemType(Enum):
    MENU = "menu"
    ACTION = "action" 
    SEPARATOR = "separator"
    SUBMENU = "submenu"

@dataclass
class MenuItem:
    """Configuration-driven menu item."""
    id: str
    title: str
    item_type: MenuItemType
    emoji: str = ""
    description: str = ""
    action: Optional[Callable] = None
    handler_module: Optional[str] = None
    handler_function: Optional[str] = None
    requirements: List[str] = field(default_factory=list)
    enabled: bool = True
    visible: bool = True
    children: List['MenuItem'] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

class MenuSystem:
    """Configuration-driven menu system."""
(dry-run)

Changes for .\core\nfc_manager.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Unified NFC Device Manager
Combines NFCDaemon and AndroidNFCVerifier functionality into a single, coherent system
"""

import subprocess
import threading
import time
import json
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from core.logging_system import get_logger, handle_errors, log_operation, track_operation
from core.config import get_config

@dataclass
class NFCDevice:
    """Unified representation of an NFC device."""
    device_id: str
    device_type: str  # 'android', 'hardware', 'pcsc'
    name: str
    status: str  # 'available', 'unavailable', 'unknown'
    capabilities: Dict[str, Any]
    connection_info: Dict[str, Any]

class UnifiedNFCManager:
    """
    Unified NFC device management combining Android and hardware NFC operations.
    Replaces both NFCDaemon and AndroidNFCVerifier with a single, coherent system.
    """
    
    def __init__(self):
        self.logger = get_logger()
        self.config = get_config()
        self.devices = {}
        self.listeners = {}
        self.running = False
        self.scan_thread = None
        
        # Android-specific setup
        self.adb_available = self._check_adb_availability()
        self.android_devices = []
        
        # Hardware NFC setup
        self.hardware_available = self._check_hardware_availability()
        self.hardware_devices = []
        
        self.logger.info("UnifiedNFCManager initialized", "NFC_INIT")
    
    @handle_errors("ADB availability check", return_on_error=False)
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Unified NFC Device Manager
Combines NFCDaemon and AndroidNFCVerifier functionality into a single, coherent system
"""

import json, subprocess, threading, time  # noqa: F401
from typing import Any, Dict, List, Optional
from dataclasses import dataclass
from core.logging_system import get_logger, handle_errors, log_operation, track_operation
from core.config import get_config

@dataclass
class NFCDevice:
    """Unified representation of an NFC device."""
    device_id: str
    device_type: str  # 'android', 'hardware', 'pcsc'
    name: str
    status: str  # 'available', 'unavailable', 'unknown'
    capabilities: Dict[str, Any]
    connection_info: Dict[str, Any]

class UnifiedNFCManager:
    """
    Unified NFC device management combining Android and hardware NFC operations.
    Replaces both NFCDaemon and AndroidNFCVerifier with a single, coherent system.
    """
    
    def __init__(self):
        self.logger = get_logger()
        self.config = get_config()
        self.devices = {}
        self.listeners = {}
        self.running = False
        self.scan_thread = None
        
        # Android-specific setup
        self.adb_available = self._check_adb_availability()
        self.android_devices = []
        
        # Hardware NFC setup
        self.hardware_available = self._check_hardware_availability()
        self.hardware_devices = []
        
        self.logger.info("UnifiedNFCManager initialized", "NFC_INIT")
    
    @handle_errors("ADB availability check", return_on_error=False)
    def _check_adb_availability(self) -> bool:
        """Check if ADB is available in system PATH."""
        try:
(dry-run)

Changes for .\core\utils\__init__.py:
--- original excerpt ---
"""
GREENWIRE Utilities Library
===========================
Common utilities and helper functions for GREENWIRE static distribution.
"""

__version__ = "1.0.0-greenwire"
__author__ = "GREENWIRE Project"

from .encoding import *
from .logging import *
from .data import *

__all__ = [
    'hex_encode',
    'hex_decode', 
    'base64_encode',
    'base64_decode',
    'tlv_parse',
    'tlv_encode',
    'setup_greenwire_logging',
    'GreenwireLogger',
]
--- proposed excerpt ---
"""
GREENWIRE Utilities Library
===========================
Common utilities and helper functions for GREENWIRE static distribution.
"""

__version__ = "1.0.0-greenwire"
__author__ = "GREENWIRE Project"

from .encoding import *  # noqa: F401
from .logging import *  # noqa: F401
from .data import *  # noqa: F401

__all__ = [
    'hex_encode',
    'hex_decode', 
    'base64_encode',
    'base64_decode',
    'tlv_parse',
    'tlv_encode',
    'setup_greenwire_logging',
    'GreenwireLogger',
]
(dry-run)

Changes for .\core\utils\data.py:
--- original excerpt ---
"""
GREENWIRE Data Utilities
=========================
Data processing and TLV parsing utilities.
"""

from typing import List, Tuple, Dict, Any, Union
import struct


class TLVError(Exception):
    """Exception raised for TLV parsing errors."""
    pass


def tlv_parse(data: bytes, offset: int = 0) -> List[Tuple[int, bytes]]:
    """
    Parse TLV (Tag-Length-Value) data.
    
    Returns:
        List of (tag, value) tuples
    """
    result = []
    pos = offset
    
    while pos < len(data):
        if pos >= len(data):
            break
        
        # Parse tag
        tag, pos = _parse_tlv_tag(data, pos)
        if pos >= len(data):
            break
        
        # Parse length
        length, pos = _parse_tlv_length(data, pos)
        if pos + length > len(data):
            raise TLVError(f"TLV length {length} exceeds remaining data")
        
        # Extract value
        value = data[pos:pos + length]
        pos += length
        
        result.append((tag, value))
    
    return result


def _parse_tlv_tag(data: bytes, pos: int) -> Tuple[int, int]:
    """Parse TLV tag and return (tag, new_position)."""
--- proposed excerpt ---
"""
GREENWIRE Data Utilities
=========================
Data processing and TLV parsing utilities.
"""

from typing import Any, Dict, List, Tuple, Union  # noqa: F401
import struct  # noqa: F401


class TLVError(Exception):
    """Exception raised for TLV parsing errors."""
    pass


def tlv_parse(data: bytes, offset: int = 0) -> List[Tuple[int, bytes]]:
    """
    Parse TLV (Tag-Length-Value) data.
    
    Returns:
        List of (tag, value) tuples
    """
    result = []
    pos = offset
    
    while pos < len(data):
        if pos >= len(data):
            break
        
        # Parse tag
        tag, pos = _parse_tlv_tag(data, pos)
        if pos >= len(data):
            break
        
        # Parse length
        length, pos = _parse_tlv_length(data, pos)
        if pos + length > len(data):
            raise TLVError(f"TLV length {length} exceeds remaining data")
        
        # Extract value
        value = data[pos:pos + length]
        pos += length
        
        result.append((tag, value))
    
    return result


def _parse_tlv_tag(data: bytes, pos: int) -> Tuple[int, int]:
    """Parse TLV tag and return (tag, new_position)."""
(dry-run)

Changes for .\core\utils\encoding.py:
--- original excerpt ---
"""
GREENWIRE Encoding Utilities
=============================
Encoding and decoding functions.
"""

import base64
import binascii
from typing import Union, List, Tuple


def hex_encode(data: bytes, separator: str = '') -> str:
    """Encode bytes as hexadecimal string."""
    hex_str = data.hex().upper()
    if separator:
        # Insert separator between each pair of hex digits
        return separator.join(hex_str[i:i+2] for i in range(0, len(hex_str), 2))
    return hex_str


def hex_decode(hex_string: str) -> bytes:
    """Decode hexadecimal string to bytes."""
    # Remove common separators
    cleaned = hex_string.replace(' ', '').replace(':', '').replace('-', '')
    try:
        return bytes.fromhex(cleaned)
    except ValueError as e:
        raise ValueError(f"Invalid hex string: {hex_string}") from e


def base64_encode(data: bytes) -> str:
    """Encode bytes as base64 string."""
    return base64.b64encode(data).decode('ascii')


def base64_decode(b64_string: str) -> bytes:
    """Decode base64 string to bytes."""
    try:
        return base64.b64decode(b64_string)
    except Exception as e:
        raise ValueError(f"Invalid base64 string: {b64_string}") from e


def url_safe_base64_encode(data: bytes) -> str:
    """Encode bytes as URL-safe base64 string."""
    return base64.urlsafe_b64encode(data).decode('ascii')


def url_safe_base64_decode(b64_string: str) -> bytes:
    """Decode URL-safe base64 string to bytes."""
--- proposed excerpt ---
"""
GREENWIRE Encoding Utilities
=============================
Encoding and decoding functions.
"""

import base64, binascii  # noqa: F401
from typing import List, Tuple, Union  # noqa: F401


def hex_encode(data: bytes, separator: str = '') -> str:
    """Encode bytes as hexadecimal string."""
    hex_str = data.hex().upper()
    if separator:
        # Insert separator between each pair of hex digits
        return separator.join(hex_str[i:i+2] for i in range(0, len(hex_str), 2))
    return hex_str


def hex_decode(hex_string: str) -> bytes:
    """Decode hexadecimal string to bytes."""
    # Remove common separators
    cleaned = hex_string.replace(' ', '').replace(':', '').replace('-', '')
    try:
        return bytes.fromhex(cleaned)
    except ValueError as e:
        raise ValueError(f"Invalid hex string: {hex_string}") from e


def base64_encode(data: bytes) -> str:
    """Encode bytes as base64 string."""
    return base64.b64encode(data).decode('ascii')


def base64_decode(b64_string: str) -> bytes:
    """Decode base64 string to bytes."""
    try:
        return base64.b64decode(b64_string)
    except Exception as e:
        raise ValueError(f"Invalid base64 string: {b64_string}") from e


def url_safe_base64_encode(data: bytes) -> str:
    """Encode bytes as URL-safe base64 string."""
    return base64.urlsafe_b64encode(data).decode('ascii')


def url_safe_base64_decode(b64_string: str) -> bytes:
    """Decode URL-safe base64 string to bytes."""
    try:
(dry-run)

Changes for .\core\utils\logging.py:
--- original excerpt ---
"""
GREENWIRE Logging Utilities
============================
Logging setup and utilities for GREENWIRE.
"""

import logging
import sys
import os
from typing import Optional
from datetime import datetime


class GreenwireFormatter(logging.Formatter):
    """Custom formatter for GREENWIRE logs."""
    
    def __init__(self, include_timestamp: bool = True):
        self.include_timestamp = include_timestamp
        if include_timestamp:
            fmt = '[%(asctime)s] %(name)s:%(levelname)s - %(message)s'
        else:
            fmt = '%(name)s:%(levelname)s - %(message)s'
        
        super().__init__(fmt, datefmt='%H:%M:%S')
    
    def format(self, record):
        # Add GREENWIRE prefix to logger names
        if not record.name.startswith('greenwire'):
            record.name = f'greenwire.{record.name}'
        return super().format(record)


class GreenwireLogger:
    """GREENWIRE logger wrapper."""
    
    def __init__(self, name: str):
        """Initialize GREENWIRE logger."""
        self.logger = logging.getLogger(f'greenwire.{name}')
        self._setup_default_handler()
    
    def _setup_default_handler(self):
        """Setup default console handler if none exists."""
        if not self.logger.handlers:
            handler = logging.StreamHandler(sys.stderr)
            handler.setFormatter(GreenwireFormatter())
            self.logger.addHandler(handler)
            self.logger.setLevel(logging.INFO)
    
    def debug(self, msg, *args, **kwargs):
        """Log debug message."""
--- proposed excerpt ---
"""
GREENWIRE Logging Utilities
============================
Logging setup and utilities for GREENWIRE.
"""

import logging, os, sys  # noqa: F401
from typing import Optional
from datetime import datetime  # noqa: F401


class GreenwireFormatter(logging.Formatter):
    """Custom formatter for GREENWIRE logs."""
    
    def __init__(self, include_timestamp: bool = True):
        self.include_timestamp = include_timestamp
        if include_timestamp:
            fmt = '[%(asctime)s] %(name)s:%(levelname)s - %(message)s'
        else:
            fmt = '%(name)s:%(levelname)s - %(message)s'
        
        super().__init__(fmt, datefmt='%H:%M:%S')
    
    def format(self, record):
        # Add GREENWIRE prefix to logger names
        if not record.name.startswith('greenwire'):
            record.name = f'greenwire.{record.name}'
        return super().format(record)


class GreenwireLogger:
    """GREENWIRE logger wrapper."""
    
    def __init__(self, name: str):
        """Initialize GREENWIRE logger."""
        self.logger = logging.getLogger(f'greenwire.{name}')
        self._setup_default_handler()
    
    def _setup_default_handler(self):
        """Setup default console handler if none exists."""
        if not self.logger.handlers:
            handler = logging.StreamHandler(sys.stderr)
            handler.setFormatter(GreenwireFormatter())
            self.logger.addHandler(handler)
            self.logger.setLevel(logging.INFO)
    
    def debug(self, msg, *args, **kwargs):
        """Log debug message."""
        self.logger.debug(msg, *args, **kwargs)
    
(dry-run)

Changes for .\emv_data\__init__.py:
--- original excerpt ---
"""
GREENWIRE EMV Data Integration Package
====================================
Production EMV/Mifare operational data integration
"""

from .emv_integration import emv_interface, execute_emv_command, parse_response, get_tag_info

__all__ = ['emv_interface', 'execute_emv_command', 'parse_response', 'get_tag_info']
--- proposed excerpt ---
"""
GREENWIRE EMV Data Integration Package
====================================
Production EMV/Mifare operational data integration
"""

from .emv_integration import emv_interface, execute_emv_command, get_tag_info, parse_response  # noqa: F401

__all__ = ['emv_interface', 'execute_emv_command', 'parse_response', 'get_tag_info']
(dry-run)

Changes for .\emv_data\commands\__init__.py:
--- original excerpt ---
"""EMV Commands Package"""

from .emv_commands import EMV_COMMANDS, get_emv_command
from .apdu_responses import APDU_RESPONSES, get_apdu_response  
from .hsm_commands import HSM_COMMANDS, get_hsm_command

__all__ = ['EMV_COMMANDS', 'get_emv_command', 'APDU_RESPONSES', 'get_apdu_response', 'HSM_COMMANDS', 'get_hsm_command']
--- proposed excerpt ---
"""EMV Commands Package"""

from .emv_commands import EMV_COMMANDS, get_emv_command  # noqa: F401
from .apdu_responses import APDU_RESPONSES, get_apdu_response  # noqa: F401
from .hsm_commands import HSM_COMMANDS, get_hsm_command  # noqa: F401

__all__ = ['EMV_COMMANDS', 'get_emv_command', 'APDU_RESPONSES', 'get_apdu_response', 'HSM_COMMANDS', 'get_hsm_command']
(dry-run)

Changes for .\emv_data\commands\emv_commands.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
EMV Commands Module - GREENWIRE Integration
==========================================
Hardcoded EMV command definitions extracted from production data
"""

from dataclasses import dataclass
from typing import Dict, List, Any

@dataclass
class EMVCommand:
    """EMV Command structure"""
    name: str
    apdu: str
    description: str
    category: str
    parameters: Dict[str, Any]
    response_codes: List[str]

# Hardcoded EMV commands from production data
EMV_COMMANDS = {
    "SELECT": EMVCommand(
        name="SELECT",
        apdu="00A40400",
        description="Select EMV application by AID",
        category="Application Selection",
        parameters={"aid": "str", "length": "int"},
        response_codes=["9000", "6A82", "6A81"]
    ),
    "GET_PROCESSING_OPTIONS": EMVCommand(
        name="GET_PROCESSING_OPTIONS",
        apdu="80A80000",
        description="Initiate application processing",
        category="Transaction Processing",
        parameters={"pdol": "str"},
        response_codes=["9000", "6985", "6A81"]
    ),
    "READ_RECORD": EMVCommand(
        name="READ_RECORD",
        apdu="00B2",
        description="Read application data record",
        category="Data Retrieval",
        parameters={"record": "int", "sfi": "int"},
        response_codes=["9000", "6A83", "6982"]
    ),
    "VERIFY": EMVCommand(
        name="VERIFY",
        apdu="0020",
        description="PIN verification",
--- proposed excerpt ---
#!/usr/bin/env python3
"""
EMV Commands Module - GREENWIRE Integration
==========================================
Hardcoded EMV command definitions extracted from production data
"""

from dataclasses import dataclass
from typing import Any, Dict, List

@dataclass
class EMVCommand:
    """EMV Command structure"""
    name: str
    apdu: str
    description: str
    category: str
    parameters: Dict[str, Any]
    response_codes: List[str]

# Hardcoded EMV commands from production data
EMV_COMMANDS = {
    "SELECT": EMVCommand(
        name="SELECT",
        apdu="00A40400",
        description="Select EMV application by AID",
        category="Application Selection",
        parameters={"aid": "str", "length": "int"},
        response_codes=["9000", "6A82", "6A81"]
    ),
    "GET_PROCESSING_OPTIONS": EMVCommand(
        name="GET_PROCESSING_OPTIONS",
        apdu="80A80000",
        description="Initiate application processing",
        category="Transaction Processing",
        parameters={"pdol": "str"},
        response_codes=["9000", "6985", "6A81"]
    ),
    "READ_RECORD": EMVCommand(
        name="READ_RECORD",
        apdu="00B2",
        description="Read application data record",
        category="Data Retrieval",
        parameters={"record": "int", "sfi": "int"},
        response_codes=["9000", "6A83", "6982"]
    ),
    "VERIFY": EMVCommand(
        name="VERIFY",
        apdu="0020",
        description="PIN verification",
(dry-run)

Changes for .\emv_data\commands\hsm_commands.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
HSM Commands Module - GREENWIRE Integration
==========================================
Hardware Security Module commands from production data
"""

from dataclasses import dataclass
from typing import Dict, List, Any, Optional

@dataclass
class HSMCommand:
    """HSM Command structure"""
    vendor: str
    command: str
    description: str
    parameters: Dict[str, Any]

# Hardcoded HSM commands from production data
HSM_COMMANDS = {
    "THALES_A0": HSMCommand(vendor="Thales", command="A0", description="Generate Key", parameters={"key_type": "str"}),
    "THALES_A2": HSMCommand(vendor="Thales", command="A2", description="Generate Key Component", parameters={"component": "str"}),
    "THALES_B0": HSMCommand(vendor="Thales", command="B0", description="Import Key", parameters={"key_data": "str"}),
    "THALES_B2": HSMCommand(vendor="Thales", command="B2", description="Export Key", parameters={"key_name": "str"}),
    "SAFENET_GK": HSMCommand(vendor="SafeNet", command="GK", description="Generate Key", parameters={"algorithm": "str"}),
    "SAFENET_EK": HSMCommand(vendor="SafeNet", command="EK", description="Encrypt Key", parameters={"key_data": "str"}),
    "SAFENET_DK": HSMCommand(vendor="SafeNet", command="DK", description="Decrypt Key", parameters={"encrypted_key": "str"}),
    "ATALLA_CMD01": HSMCommand(vendor="Atalla", command="CMD01", description="Key Generation", parameters={"key_type": "str"}),
    "ATALLA_CMD02": HSMCommand(vendor="Atalla", command="CMD02", description="PIN Verification", parameters={"pin_block": "str"}),
    "ATALLA_CMD03": HSMCommand(vendor="Atalla", command="CMD03", description="MAC Generation", parameters={"data": "str"}),
}

def get_hsm_command(vendor: str, command: str) -> Optional[HSMCommand]:
    """Get HSM command by vendor and command"""
    key = f"{vendor}_{command}".replace(" ", "_").upper()
    return HSM_COMMANDS.get(key)

def get_vendor_commands(vendor: str) -> List[HSMCommand]:
    """Get all commands for a specific vendor"""
    return [cmd for cmd in HSM_COMMANDS.values() if cmd.vendor.upper() == vendor.upper()]

def list_vendors() -> List[str]:
    """List all HSM vendors"""
    return list(set(cmd.vendor for cmd in HSM_COMMANDS.values()))

def list_hsm_commands() -> List[str]:
    """List all HSM command keys"""
    return list(HSM_COMMANDS.keys())
--- proposed excerpt ---
#!/usr/bin/env python3
"""
HSM Commands Module - GREENWIRE Integration
==========================================
Hardware Security Module commands from production data
"""

from dataclasses import dataclass
from typing import Any, Dict, List, Optional

@dataclass
class HSMCommand:
    """HSM Command structure"""
    vendor: str
    command: str
    description: str
    parameters: Dict[str, Any]

# Hardcoded HSM commands from production data
HSM_COMMANDS = {
    "THALES_A0": HSMCommand(vendor="Thales", command="A0", description="Generate Key", parameters={"key_type": "str"}),
    "THALES_A2": HSMCommand(vendor="Thales", command="A2", description="Generate Key Component", parameters={"component": "str"}),
    "THALES_B0": HSMCommand(vendor="Thales", command="B0", description="Import Key", parameters={"key_data": "str"}),
    "THALES_B2": HSMCommand(vendor="Thales", command="B2", description="Export Key", parameters={"key_name": "str"}),
    "SAFENET_GK": HSMCommand(vendor="SafeNet", command="GK", description="Generate Key", parameters={"algorithm": "str"}),
    "SAFENET_EK": HSMCommand(vendor="SafeNet", command="EK", description="Encrypt Key", parameters={"key_data": "str"}),
    "SAFENET_DK": HSMCommand(vendor="SafeNet", command="DK", description="Decrypt Key", parameters={"encrypted_key": "str"}),
    "ATALLA_CMD01": HSMCommand(vendor="Atalla", command="CMD01", description="Key Generation", parameters={"key_type": "str"}),
    "ATALLA_CMD02": HSMCommand(vendor="Atalla", command="CMD02", description="PIN Verification", parameters={"pin_block": "str"}),
    "ATALLA_CMD03": HSMCommand(vendor="Atalla", command="CMD03", description="MAC Generation", parameters={"data": "str"}),
}

def get_hsm_command(vendor: str, command: str) -> Optional[HSMCommand]:
    """Get HSM command by vendor and command"""
    key = f"{vendor}_{command}".replace(" ", "_").upper()
    return HSM_COMMANDS.get(key)

def get_vendor_commands(vendor: str) -> List[HSMCommand]:
    """Get all commands for a specific vendor"""
    return [cmd for cmd in HSM_COMMANDS.values() if cmd.vendor.upper() == vendor.upper()]

def list_vendors() -> List[str]:
    """List all HSM vendors"""
    return list(set(cmd.vendor for cmd in HSM_COMMANDS.values()))

def list_hsm_commands() -> List[str]:
    """List all HSM command keys"""
    return list(HSM_COMMANDS.keys())
(dry-run)

Changes for .\emv_data\emv_integration.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE EMV Integration Module
===============================
Main interface for EMV/Mifare operational data
"""

import json
from pathlib import Path
from typing import Dict, List, Any, Optional

# Import all EMV modules
try:
    from .commands.emv_commands import EMV_COMMANDS, get_emv_command, list_emv_commands
    from .commands.apdu_responses import APDU_RESPONSES, get_apdu_response, is_success
    from .commands.hsm_commands import HSM_COMMANDS, get_hsm_command, list_vendors
except ImportError:
    # Handle relative imports when run directly
    import sys
    sys.path.append(str(Path(__file__).parent))
    from commands.emv_commands import EMV_COMMANDS, get_emv_command, list_emv_commands
    from commands.apdu_responses import APDU_RESPONSES, get_apdu_response, is_success
    from commands.hsm_commands import HSM_COMMANDS, get_hsm_command, list_vendors

class GREENWIREEMVInterface:
    """Main EMV interface for GREENWIRE"""
    
    def __init__(self):
        self.data_path = Path(__file__).parent / "reference"
        self.reference_data = self._load_reference_data()
    
    def _load_reference_data(self) -> Dict[str, Any]:
        """Load reference data from JSON"""
        ref_file = self.data_path / "emv_reference_data.json"
        try:
            with open(ref_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
    
    def execute_emv_command(self, command_name: str, **kwargs) -> Dict[str, Any]:
        """Execute EMV command with parameters"""
        cmd = get_emv_command(command_name)
        if not cmd:
            return {"error": f"Command {command_name} not found"}
        
        # Validate parameters
        missing_params = []
        for param in cmd.parameters:
            if param not in kwargs:
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE EMV Integration Module
===============================
Main interface for EMV/Mifare operational data
"""

import json
from pathlib import Path
from typing import Any, Dict, List, Optional  # noqa: F401

# Import all EMV modules
try:
    from .commands.emv_commands import EMV_COMMANDS, get_emv_command, list_emv_commands
    from .commands.apdu_responses import APDU_RESPONSES, get_apdu_response, is_success
    from .commands.hsm_commands import HSM_COMMANDS, get_hsm_command, list_vendors
except ImportError:
    # Handle relative imports when run directly
    import sys
    sys.path.append(str(Path(__file__).parent))
    from commands.emv_commands import EMV_COMMANDS, get_emv_command, list_emv_commands
    from commands.apdu_responses import APDU_RESPONSES, get_apdu_response, is_success
    from commands.hsm_commands import HSM_COMMANDS, get_hsm_command, list_vendors

class GREENWIREEMVInterface:
    """Main EMV interface for GREENWIRE"""
    
    def __init__(self):
        self.data_path = Path(__file__).parent / "reference"
        self.reference_data = self._load_reference_data()
    
    def _load_reference_data(self) -> Dict[str, Any]:
        """Load reference data from JSON"""
        ref_file = self.data_path / "emv_reference_data.json"
        try:
            with open(ref_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
    
    def execute_emv_command(self, command_name: str, **kwargs) -> Dict[str, Any]:
        """Execute EMV command with parameters"""
        cmd = get_emv_command(command_name)
        if not cmd:
            return {"error": f"Command {command_name} not found"}
        
        # Validate parameters
        missing_params = []
        for param in cmd.parameters:
            if param not in kwargs:
(dry-run)

Changes for .\emv_data\test_emv.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE EMV Test Module
========================
Simple test of EMV integration functionality
"""

import sys
import os

# Add the parent directory to path for imports
sys.path.append(os.path.dirname(__file__))

# Test EMV Commands
try:
    from commands.emv_commands import EMV_COMMANDS, get_emv_command, list_emv_commands
    print("✅ EMV Commands module loaded successfully")
    print(f"📊 Available commands: {len(EMV_COMMANDS)}")
    for cmd in list(EMV_COMMANDS.keys())[:3]:
        print(f"  - {cmd}")
except Exception as e:
    print(f"❌ EMV Commands error: {e}")

# Test APDU Responses
try:
    from commands.apdu_responses import APDU_RESPONSES, get_apdu_response, is_success
    print("\n✅ APDU Responses module loaded successfully") 
    print(f"📊 Available response codes: {len(APDU_RESPONSES)}")
    test_codes = ["9000", "6A82", "6985"]
    for code in test_codes:
        resp = get_apdu_response(code)
        if resp:
            print(f"  - {code}: {resp.description}")
except Exception as e:
    print(f"\n❌ APDU Responses error: {e}")

# Test HSM Commands
try:
    from commands.hsm_commands import HSM_COMMANDS, get_vendor_commands, list_vendors
    print("\n✅ HSM Commands module loaded successfully")
    print(f"📊 Available HSM commands: {len(HSM_COMMANDS)}")
    vendors = list_vendors()
    for vendor in vendors[:2]:
        cmds = get_vendor_commands(vendor)
        print(f"  - {vendor}: {len(cmds)} commands")
except Exception as e:
    print(f"\n❌ HSM Commands error: {e}")

print("\n🎯 GREENWIRE EMV Integration Test Complete!")
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE EMV Test Module
========================
Simple test of EMV integration functionality
"""

import os, sys

# Add the parent directory to path for imports
sys.path.append(os.path.dirname(__file__))

# Test EMV Commands
try:
    from commands.emv_commands import EMV_COMMANDS, get_emv_command, list_emv_commands
    print("✅ EMV Commands module loaded successfully")
    print(f"📊 Available commands: {len(EMV_COMMANDS)}")
    for cmd in list(EMV_COMMANDS.keys())[:3]:
        print(f"  - {cmd}")
except Exception as e:
    print(f"❌ EMV Commands error: {e}")

# Test APDU Responses
try:
    from commands.apdu_responses import APDU_RESPONSES, get_apdu_response, is_success
    print("\n✅ APDU Responses module loaded successfully") 
    print(f"📊 Available response codes: {len(APDU_RESPONSES)}")
    test_codes = ["9000", "6A82", "6985"]
    for code in test_codes:
        resp = get_apdu_response(code)
        if resp:
            print(f"  - {code}: {resp.description}")
except Exception as e:
    print(f"\n❌ APDU Responses error: {e}")

# Test HSM Commands
try:
    from commands.hsm_commands import HSM_COMMANDS, get_vendor_commands, list_vendors
    print("\n✅ HSM Commands module loaded successfully")
    print(f"📊 Available HSM commands: {len(HSM_COMMANDS)}")
    vendors = list_vendors()
    for vendor in vendors[:2]:
        cmds = get_vendor_commands(vendor)
        print(f"  - {vendor}: {len(cmds)} commands")
except Exception as e:
    print(f"\n❌ HSM Commands error: {e}")

print("\n🎯 GREENWIRE EMV Integration Test Complete!")
(dry-run)

Changes for .\emv_data_integrator.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE EMV Data Integration Module
====================================
Comprehensive EMV/Mifare operational data extraction and integration
Processes production data from scrapes and integrates into GREENWIRE
"""

import os
import re
import json
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict

@dataclass
class EMVCommand:
    """EMV Command structure"""
    name: str
    apdu: str
    description: str
    category: str
    parameters: Dict[str, Any]
    response_codes: List[str]

@dataclass
class EMVTag:
    """EMV Tag structure"""
    tag: str
    name: str
    description: str
    format: str
    source: str

@dataclass
class APDUResponse:
    """APDU Response code structure"""
    code: str
    description: str
    category: str

@dataclass
class HSMCommand:
    """HSM Command structure"""
    vendor: str
    command: str
    description: str
    parameters: Dict[str, Any]

class GREENWIREEMVIntegrator:
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE EMV Data Integration Module
====================================
Comprehensive EMV/Mifare operational data extraction and integration
Processes production data from scrapes and integrates into GREENWIRE
"""

import json, os, re
from pathlib import Path
from typing import Any, Dict, List, Optional  # noqa: F401
from dataclasses import asdict, dataclass

@dataclass
class EMVCommand:
    """EMV Command structure"""
    name: str
    apdu: str
    description: str
    category: str
    parameters: Dict[str, Any]
    response_codes: List[str]

@dataclass
class EMVTag:
    """EMV Tag structure"""
    tag: str
    name: str
    description: str
    format: str
    source: str

@dataclass
class APDUResponse:
    """APDU Response code structure"""
    code: str
    description: str
    category: str

@dataclass
class HSMCommand:
    """HSM Command structure"""
    vendor: str
    command: str
    description: str
    parameters: Dict[str, Any]

class GREENWIREEMVIntegrator:
    """Main EMV data integration class"""
    
(dry-run)

Changes for .\emv_data_translator.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
EMV Data Translation Script
===========================
Translates Chinese content to English in the converted EMV files
"""

import os
import re
from pathlib import Path

class EMVDataTranslator:
    def __init__(self, base_path):
        self.base_path = Path(base_path)
        
        # Translation dictionary for common Chinese terms
        self.translations = {
            # File names and titles
            "终端交易类型": "Terminal Transaction Type",
            "控件": "Control/Widget", 
            "原生": "Native",
            "与": "and",
            "互转": "Mutual Conversion",
            "使用": "Using",
            "实现": "Implementation",
            
            # EMV specific terms
            "交易类型": "Transaction Type",
            "终端": "Terminal", 
            "商品": "Goods",
            "服务": "Service",
            "现金": "Cash",
            "退款": "Refund", 
            "余额查询": "Balance Inquiry",
            "返现": "CashBack",
            
            # Android/Technical terms
            "控件": "Widget",
            "组件": "Component",
            "布局": "Layout",
            "活动": "Activity",
            "页面": "Page",
            "界面": "Interface",
            "数据": "Data",
            "转换": "Conversion",
            "方法": "Method",
            "函数": "Function",
            "类": "Class",
            "对象": "Object",
            "属性": "Property",
--- proposed excerpt ---
#!/usr/bin/env python3
"""
EMV Data Translation Script
===========================
Translates Chinese content to English in the converted EMV files
"""

import os, re  # noqa: F401
from pathlib import Path

class EMVDataTranslator:
    def __init__(self, base_path):
        self.base_path = Path(base_path)
        
        # Translation dictionary for common Chinese terms
        self.translations = {
            # File names and titles
            "终端交易类型": "Terminal Transaction Type",
            "控件": "Control/Widget", 
            "原生": "Native",
            "与": "and",
            "互转": "Mutual Conversion",
            "使用": "Using",
            "实现": "Implementation",
            
            # EMV specific terms
            "交易类型": "Transaction Type",
            "终端": "Terminal", 
            "商品": "Goods",
            "服务": "Service",
            "现金": "Cash",
            "退款": "Refund", 
            "余额查询": "Balance Inquiry",
            "返现": "CashBack",
            
            # Android/Technical terms
            "控件": "Widget",
            "组件": "Component",
            "布局": "Layout",
            "活动": "Activity",
            "页面": "Page",
            "界面": "Interface",
            "数据": "Data",
            "转换": "Conversion",
            "方法": "Method",
            "函数": "Function",
            "类": "Class",
            "对象": "Object",
            "属性": "Property",
            "配置": "Configuration",
(dry-run)

Changes for .\emv_data_verification.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
Quick EMV Data Verification Script
==================================
Verifies and extracts key operational data from converted EMV files
"""

import json
import re
from pathlib import Path

def extract_apdu_codes():
    """Extract APDU response codes from converted file"""
    apdu_file = Path("d:/repo/scrapes/converted_markdown/emv.cool/2020/12/23/Complete-list-of-APDU-responses/index.md")
    if apdu_file.exists():
        with open(apdu_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Extract table rows with APDU codes
        apdu_patterns = re.findall(r'(\w+)\s*\|\s*(\w*)\s*\|\s*([EWI])\s*\|\s*([^|]+)', content)
        print(f"Found {len(apdu_patterns)} APDU response codes")
        
        # Show first 10 codes
        print("\nFirst 10 APDU Response Codes:")
        for sw1, sw2, type_code, description in apdu_patterns[:10]:
            print(f"  {sw1}{sw2}: [{type_code}] {description.strip()}")
    else:
        print("APDU file not found")

def extract_aids():
    """Extract Application Identifiers from converted file"""
    aid_file = Path("d:/repo/scrapes/converted_markdown/emv.cool/2020/12/23/Complete-list-of-application-identifiers-AID/index.md")
    if aid_file.exists():
        with open(aid_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Extract AID patterns (hex strings 10+ characters)
        aid_patterns = re.findall(r'([0-9A-Fa-f]{10,})\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)', content)
        print(f"\nFound {len(aid_patterns)} Application Identifiers")
        
        # Show Visa/MC/AMEX AIDs
        print("\nMajor Payment Brand AIDs:")
        for aid, vendor, country, name in aid_patterns[:15]:
            if 'visa' in vendor.lower() or 'mastercard' in vendor.lower() or 'american express' in vendor.lower():
                print(f"  {aid}: {vendor} - {name.strip()}")
    else:
        print("AID file not found")

def extract_emv_tags():
    """Extract EMV tag definitions from converted file"""
--- proposed excerpt ---
#!/usr/bin/env python3
"""
Quick EMV Data Verification Script
==================================
Verifies and extracts key operational data from converted EMV files
"""

import json, re  # noqa: F401
from pathlib import Path

def extract_apdu_codes():
    """Extract APDU response codes from converted file"""
    apdu_file = Path("d:/repo/scrapes/converted_markdown/emv.cool/2020/12/23/Complete-list-of-APDU-responses/index.md")
    if apdu_file.exists():
        with open(apdu_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Extract table rows with APDU codes
        apdu_patterns = re.findall(r'(\w+)\s*\|\s*(\w*)\s*\|\s*([EWI])\s*\|\s*([^|]+)', content)
        print(f"Found {len(apdu_patterns)} APDU response codes")
        
        # Show first 10 codes
        print("\nFirst 10 APDU Response Codes:")
        for sw1, sw2, type_code, description in apdu_patterns[:10]:
            print(f"  {sw1}{sw2}: [{type_code}] {description.strip()}")
    else:
        print("APDU file not found")

def extract_aids():
    """Extract Application Identifiers from converted file"""
    aid_file = Path("d:/repo/scrapes/converted_markdown/emv.cool/2020/12/23/Complete-list-of-application-identifiers-AID/index.md")
    if aid_file.exists():
        with open(aid_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Extract AID patterns (hex strings 10+ characters)
        aid_patterns = re.findall(r'([0-9A-Fa-f]{10,})\s*\|\s*([^|]+)\s*\|\s*([^|]+)\s*\|\s*([^|]+)', content)
        print(f"\nFound {len(aid_patterns)} Application Identifiers")
        
        # Show Visa/MC/AMEX AIDs
        print("\nMajor Payment Brand AIDs:")
        for aid, vendor, country, name in aid_patterns[:15]:
            if 'visa' in vendor.lower() or 'mastercard' in vendor.lower() or 'american express' in vendor.lower():
                print(f"  {aid}: {vendor} - {name.strip()}")
    else:
        print("AID file not found")

def extract_emv_tags():
    """Extract EMV tag definitions from converted file"""
    tag_file = Path("d:/repo/scrapes/converted_markdown/emv.cool/2020/12/23/Complete-list-of-EMV-NFC-tags/index.md")
(dry-run)

Changes for .\emv_nfc_verify.py:
--- original excerpt ---
#!/usr/bin/env python3
"""EMV NFC Verification Module for GREENWIRE.

This module provides EMV-specific NFC verification capabilities including
AID testing, GPO commands, and CAP file personalization.
"""

import os
import sys
import time
import json
import subprocess
from typing import Optional, List, Dict, Any, Tuple
from pathlib import Path

# Common EMV AIDs for testing
COMMON_EMVCO_AIDS = [
    "A0000000031010",  # Visa Classic
    "A0000000032010",  # Visa Electron
    "A0000000033010",  # Visa Interlink
    "A0000000041010",  # Mastercard Credit
    "A0000000042010",  # Mastercard Debit
    "A0000000043010",  # Mastercard Maestro
    "A0000000031020",  # Visa
    "A0000000041020",  # Mastercard
    "A000000003101001", # Visa International
    "A000000004101001", # Mastercard International
    "A0000000250000",   # American Express
    "A0000000651010",   # Discover
    "A0000000152000",   # JPCS
    "A0000000333010",   # Paypass
]

# Import required modules with fallbacks
try:
    from apdu_communicator import APDUCommunicator
    HAS_APDU_COMM = True
except ImportError:
    HAS_APDU_COMM = False

try:
    import nfc
    HAS_NFC = True
except ImportError:
    HAS_NFC = False

try:
    from smartcard.System import readers
    from smartcard.util import toHexString, toBytes
    HAS_PYSCARD = True
--- proposed excerpt ---
#!/usr/bin/env python3
"""EMV NFC Verification Module for GREENWIRE.

This module provides EMV-specific NFC verification capabilities including
AID testing, GPO commands, and CAP file personalization.
"""

import json, os, subprocess, sys, time  # noqa: F401
from typing import Any, Dict, List, Optional, Tuple  # noqa: F401
from pathlib import Path  # noqa: F401

# Common EMV AIDs for testing
COMMON_EMVCO_AIDS = [
    "A0000000031010",  # Visa Classic
    "A0000000032010",  # Visa Electron
    "A0000000033010",  # Visa Interlink
    "A0000000041010",  # Mastercard Credit
    "A0000000042010",  # Mastercard Debit
    "A0000000043010",  # Mastercard Maestro
    "A0000000031020",  # Visa
    "A0000000041020",  # Mastercard
    "A000000003101001", # Visa International
    "A000000004101001", # Mastercard International
    "A0000000250000",   # American Express
    "A0000000651010",   # Discover
    "A0000000152000",   # JPCS
    "A0000000333010",   # Paypass
]

# Import required modules with fallbacks
try:
    from apdu_communicator import APDUCommunicator
    HAS_APDU_COMM = True
except ImportError:
    HAS_APDU_COMM = False

try:
    import nfc
    HAS_NFC = True
except ImportError:
    HAS_NFC = False

try:
    from smartcard.System import readers
    from smartcard.util import toHexString, toBytes
    HAS_PYSCARD = True
except ImportError:
    HAS_PYSCARD = False


(dry-run)

Changes for .\enhanced_emv_translator.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
Enhanced EMV Data Translation Script
===================================
More comprehensive translation of Chinese content to English
"""

import os
import re
from pathlib import Path

class EnhancedEMVTranslator:
    def __init__(self, base_path):
        self.base_path = Path(base_path)
        
        # Comprehensive translation dictionary
        self.translations = {
            # Website/UI elements
            "首页": "Home",
            "归档": "Archives", 
            "标签": "Tags",
            "友链": "Friends",
            "关于": "About",
            "上一篇": "Previous",
            "下一篇": "Next",
            "目录": "Contents",
            "版权所有": "Copyright",
            "主题": "Theme",
            "技术支持": "Powered by",
            
            # EMV/Technical terms
            "终端交易类型": "Terminal Transaction Type",
            "终端": "Terminal",
            "交易类型": "Transaction Type",
            "交易": "Transaction",
            "类型": "Type",
            "商品": "Goods",
            "服务": "Service", 
            "现金": "Cash",
            "退款": "Refund",
            "余额查询": "Balance Inquiry",
            "返现": "CashBack",
            "查询": "Inquiry",
            "余额": "Balance",
            
            # Android/Programming terms
            "控件": "Widget",
            "组件": "Component",
            "原生": "Native", 
            "使用": "Using",
--- proposed excerpt ---
#!/usr/bin/env python3
"""
Enhanced EMV Data Translation Script
===================================
More comprehensive translation of Chinese content to English
"""

import os, re  # noqa: F401
from pathlib import Path

class EnhancedEMVTranslator:
    def __init__(self, base_path):
        self.base_path = Path(base_path)
        
        # Comprehensive translation dictionary
        self.translations = {
            # Website/UI elements
            "首页": "Home",
            "归档": "Archives", 
            "标签": "Tags",
            "友链": "Friends",
            "关于": "About",
            "上一篇": "Previous",
            "下一篇": "Next",
            "目录": "Contents",
            "版权所有": "Copyright",
            "主题": "Theme",
            "技术支持": "Powered by",
            
            # EMV/Technical terms
            "终端交易类型": "Terminal Transaction Type",
            "终端": "Terminal",
            "交易类型": "Transaction Type",
            "交易": "Transaction",
            "类型": "Type",
            "商品": "Goods",
            "服务": "Service", 
            "现金": "Cash",
            "退款": "Refund",
            "余额查询": "Balance Inquiry",
            "返现": "CashBack",
            "查询": "Inquiry",
            "余额": "Balance",
            
            # Android/Programming terms
            "控件": "Widget",
            "组件": "Component",
            "原生": "Native", 
            "使用": "Using",
            "实现": "Implementation",
(dry-run)

Changes for .\final_translation_cleanup.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
Final EMV Data Translation Cleanup
==================================
Clean up remaining Chinese characters
"""

import os
import re
from pathlib import Path

def final_cleanup_translation():
    """Final cleanup of remaining Chinese characters"""
    base_path = Path("d:/repo/scrapes/converted_markdown")
    
    # Additional translations for remaining characters
    cleanup_translations = {
        "核": "Core",
        "云": "Cloud", 
        "器": "Server/Device",
        "核云器": "Core Cloud Server",
        "腾讯云": "Tencent Cloud",
        "云服务器": "Cloud Server",
        "产品": "Product",
        "限时": "Limited Time",
        "秒杀": "Flash Sale",
        "爆款": "Popular/Hot",
        "首年": "First Year",
        "优惠": "Discount",
        "特价": "Special Price",
        "元起": "Yuan/Starting from",
        "元": "Yuan",
        "起": "Starting from",
        
        # Navigation terms that might remain
        "关于": "About",
        "友链": "Links", 
        "标签": "Tags",
        "归档": "Archive",
        "首页": "Home",
        "目录": "Contents",
        
        # Any remaining single characters
        "的": "",  # Remove particle
        "和": "and",
        "与": "and", 
        "等": "etc",
        "及": "and",
        "或": "or",
        "但": "but",
--- proposed excerpt ---
#!/usr/bin/env python3
"""
Final EMV Data Translation Cleanup
==================================
Clean up remaining Chinese characters
"""

import os, re  # noqa: F401
from pathlib import Path

def final_cleanup_translation():
    """Final cleanup of remaining Chinese characters"""
    base_path = Path("d:/repo/scrapes/converted_markdown")
    
    # Additional translations for remaining characters
    cleanup_translations = {
        "核": "Core",
        "云": "Cloud", 
        "器": "Server/Device",
        "核云器": "Core Cloud Server",
        "腾讯云": "Tencent Cloud",
        "云服务器": "Cloud Server",
        "产品": "Product",
        "限时": "Limited Time",
        "秒杀": "Flash Sale",
        "爆款": "Popular/Hot",
        "首年": "First Year",
        "优惠": "Discount",
        "特价": "Special Price",
        "元起": "Yuan/Starting from",
        "元": "Yuan",
        "起": "Starting from",
        
        # Navigation terms that might remain
        "关于": "About",
        "友链": "Links", 
        "标签": "Tags",
        "归档": "Archive",
        "首页": "Home",
        "目录": "Contents",
        
        # Any remaining single characters
        "的": "",  # Remove particle
        "和": "and",
        "与": "and", 
        "等": "etc",
        "及": "and",
        "或": "or",
        "但": "but",
        "为": "as/for",
(dry-run)

Changes for .\greenwire.py:
--- original excerpt ---
#!/usr/bin/env python3
"""GREENWIRE command line interface.

A simplified entry point for performing smartcard fuzzing, NFC tasks and
EMV terminal/card emulation.

[EMULATION] This script supports wireless terminal mode (--wireless) and
optional Dynamic Data Authentication (--dda).
"""

import os
import sys
import shutil
import subprocess

# Add core modules to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'core'))

# Core system imports - must be first
from core.config import get_config
from core.logging_system import get_logger, setup_logging, handle_errors, log_operation
from core.imports import ModuleManager
from core.menu_system import get_menu_system
from core.nfc_manager import get_nfc_manager
from core.global_defaults import load_defaults, update_defaults

# Menu action handlers
import menu_handlers

# Standard library imports
import argparse
import subprocess
import json
import random
import time
import threading
import base64
from datetime import datetime
from pathlib import Path

# ADB command timing cache
_ADB_TIMING_LOG = []
_LAST_ADB_RESTART = 0
ADB_RESTART_CACHE_SECONDS = 30


def adb_cmd(args: list, restart: bool = True, timeout: int = 10, cache_restart: bool = True) -> dict:
    """Execute ADB command with optional server restart and timing metrics.
    
    Args:
--- proposed excerpt ---
#!/usr/bin/env python3
"""GREENWIRE command line interface.

A simplified entry point for performing smartcard fuzzing, NFC tasks and
EMV terminal/card emulation.

[EMULATION] This script supports wireless terminal mode (--wireless) and
optional Dynamic Data Authentication (--dda).
"""

import argparse, base64, json, menu_handlers, os, random, shutil, subprocess, sys, threading, time

# Add core modules to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'core'))

# Core system imports - must be first
from core.config import get_config
from core.logging_system import get_logger, handle_errors, log_operation, setup_logging  # noqa: F401
from core.imports import ModuleManager
from core.menu_system import get_menu_system
from core.nfc_manager import get_nfc_manager
from core.global_defaults import load_defaults, update_defaults

# Menu action handlers

# Standard library imports
from datetime import datetime
from pathlib import Path

# ADB command timing cache
_ADB_TIMING_LOG = []
_LAST_ADB_RESTART = 0
ADB_RESTART_CACHE_SECONDS = 30


def adb_cmd(args: list, restart: bool = True, timeout: int = 10, cache_restart: bool = True) -> dict:
    """Execute ADB command with optional server restart and timing metrics.
    
    Args:
        args: ADB command arguments (without 'adb' prefix)
        restart: Force server restart before command
        timeout: Command timeout in seconds
        cache_restart: Cache restart for ADB_RESTART_CACHE_SECONDS to reduce overhead
    
    Returns:
        Dict with ok, stdout, stderr, timing_ms, restart_used keys
    """
    global _LAST_ADB_RESTART
    
    adb = shutil.which("adb")
(dry-run)

Changes for .\greenwire\__init__.py:
--- original excerpt ---
"""Greenwire package providing EMV and smartcard testing utilities."""

from .core.nfc_iso import (
    ISO14443ReaderWriter,
    ISO15693ReaderWriter,
    ISO18092ReaderWriter,
    AndroidReaderWriter,
)
from .nfc_vuln import scan_nfc_vulnerabilities

__all__ = [
    "ISO14443ReaderWriter",
    "ISO15693ReaderWriter",
    "ISO18092ReaderWriter",
    "AndroidReaderWriter",
    "scan_nfc_vulnerabilities",
]
--- proposed excerpt ---
"""Greenwire package providing EMV and smartcard testing utilities."""

from .core.nfc_iso import (
    ISO14443ReaderWriter,
    ISO15693ReaderWriter,
    ISO18092ReaderWriter,
    AndroidReaderWriter,
)
from .nfc_vuln import scan_nfc_vulnerabilities  # noqa: F401

__all__ = [
    "ISO14443ReaderWriter",
    "ISO15693ReaderWriter",
    "ISO18092ReaderWriter",
    "AndroidReaderWriter",
    "scan_nfc_vulnerabilities",
]
(dry-run)

Changes for .\greenwire\core\backend.py:
--- original excerpt ---
import sqlite3
import hashlib
import logging
from pathlib import Path
from typing import Optional

from .emv_generator import generate_card
from .nfc_iso import AndroidReaderWriter

# Secret used for hashing; in real deployments this should come from
# a secure source such as an environment variable or secrets manager.
SECRET = "GREENWIRE_SECRET"


def init_backend(db_path: str | Path = "card_data.db") -> sqlite3.Connection:
    """Initialize the backend database and return a connection."""
    conn = sqlite3.connect(db_path)
    conn.execute(
        "CREATE TABLE IF NOT EXISTS cards ("
        "verification_code TEXT PRIMARY KEY, pan_hash TEXT UNIQUE)"
    )
    return conn


def _pan_hash(pan: str) -> str:
    """Return a salted hash of the PAN for static validation."""
    return hashlib.sha256((pan + SECRET).encode()).hexdigest()


def issue_card(
    conn: sqlite3.Connection,
    issuer: str = "TEST BANK",
    iin: str = "400000",
    pan: Optional[str] = None,
) -> dict:
    """Generate a card, store validation data, and return it."""
    card = generate_card(issuer, iin)
    if pan is not None:
        card["pan"] = pan
    pan_hash = _pan_hash(card["pan"])
    verification_code = hashlib.sha256(
        (card["pan"] + card["expiry"] + SECRET).encode()
    ).hexdigest()[:16]
    if conn.execute(
        "SELECT 1 FROM cards WHERE pan_hash = ?", (pan_hash,)
    ).fetchone():
        raise ValueError("Duplicate card detected")
    conn.execute(
        "INSERT INTO cards (verification_code, pan_hash) VALUES (?, ?)",
        (verification_code, pan_hash),
--- proposed excerpt ---
import hashlib, logging, sqlite3
from pathlib import Path
from typing import Optional

from .emv_generator import generate_card
from .nfc_iso import AndroidReaderWriter

# Secret used for hashing; in real deployments this should come from
# a secure source such as an environment variable or secrets manager.
SECRET = "GREENWIRE_SECRET"


def init_backend(db_path: str | Path = "card_data.db") -> sqlite3.Connection:
    """Initialize the backend database and return a connection."""
    conn = sqlite3.connect(db_path)
    conn.execute(
        "CREATE TABLE IF NOT EXISTS cards ("
        "verification_code TEXT PRIMARY KEY, pan_hash TEXT UNIQUE)"
    )
    return conn


def _pan_hash(pan: str) -> str:
    """Return a salted hash of the PAN for static validation."""
    return hashlib.sha256((pan + SECRET).encode()).hexdigest()


def issue_card(
    conn: sqlite3.Connection,
    issuer: str = "TEST BANK",
    iin: str = "400000",
    pan: Optional[str] = None,
) -> dict:
    """Generate a card, store validation data, and return it."""
    card = generate_card(issuer, iin)
    if pan is not None:
        card["pan"] = pan
    pan_hash = _pan_hash(card["pan"])
    verification_code = hashlib.sha256(
        (card["pan"] + card["expiry"] + SECRET).encode()
    ).hexdigest()[:16]
    if conn.execute(
        "SELECT 1 FROM cards WHERE pan_hash = ?", (pan_hash,)
    ).fetchone():
        raise ValueError("Duplicate card detected")
    conn.execute(
        "INSERT INTO cards (verification_code, pan_hash) VALUES (?, ?)",
        (verification_code, pan_hash),
    )
    conn.commit()
(dry-run)

Changes for .\greenwire\core\crypto_engine.py:
--- original excerpt ---
"""
GREENWIRE Cryptographic Engine (crypto_engine.py)
-------------------------------------------------
Purpose: Provides cryptographic primitives (RSA, ECC, AES, hashing, signing, verification, encryption, decryption) for the GREENWIRE suite.
Relative to: Used by GREENWIRE CLI, emulators, and test suites for smartcard/EMV/JCOP protocol simulation and security testing.
Protocols: EMV, ISO 7816, JavaCard, PKCS#1, PKCS#7, FIPS 186-4, and related cryptographic standards.
"""
import hashlib
import logging
from typing import Tuple
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding, ed25519
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes, aead
from cryptography.hazmat.backends import default_backend

logger = logging.getLogger("crypto_engine")

def generate_rsa_key(key_size: int = 2048) -> rsa.RSAPrivateKey:
    """Generate an RSA private key."""
    try:
        return rsa.generate_private_key(public_exponent=65537, key_size=key_size)
    except Exception as e:
        logger.error(f"RSA key generation failed: {e}")
        raise

def rsa_sign(private_key: rsa.RSAPrivateKey, data: bytes) -> bytes:
    """Sign data with RSA using SHA-256."""
    try:
        return private_key.sign(data, padding.PKCS1v15(), hashes.SHA256())
    except Exception as e:
        logger.error(f"RSA sign failed: {e}")
        raise

def rsa_verify(public_key: rsa.RSAPublicKey, signature: bytes, data: bytes) -> bool:
    """Verify RSA signature."""
    try:
        public_key.verify(signature, data, padding.PKCS1v15(), hashes.SHA256())
        return True
    except Exception as e:
        logger.warning(f"RSA verify failed: {e}")
        return False

def rsa_encrypt(public_key: rsa.RSAPublicKey, data: bytes) -> bytes:
    """Encrypt data with RSA using OAEP."""
    try:
        return public_key.encrypt(
            data,
            padding.OAEP(
                mgf=padding.MGF1(hashes.SHA256()),
                algorithm=hashes.SHA256(),
--- proposed excerpt ---
"""
GREENWIRE Cryptographic Engine (crypto_engine.py)
-------------------------------------------------
Purpose: Provides cryptographic primitives (RSA, ECC, AES, hashing, signing, verification, encryption, decryption) for the GREENWIRE suite.
Relative to: Used by GREENWIRE CLI, emulators, and test suites for smartcard/EMV/JCOP protocol simulation and security testing.
Protocols: EMV, ISO 7816, JavaCard, PKCS#1, PKCS#7, FIPS 186-4, and related cryptographic standards.
"""
import hashlib, logging
from typing import Tuple
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec, ed25519, padding, rsa
from cryptography.hazmat.primitives.ciphers import Cipher, aead, algorithms, modes
from cryptography.hazmat.backends import default_backend

logger = logging.getLogger("crypto_engine")

def generate_rsa_key(key_size: int = 2048) -> rsa.RSAPrivateKey:
    """Generate an RSA private key."""
    try:
        return rsa.generate_private_key(public_exponent=65537, key_size=key_size)
    except Exception as e:
        logger.error(f"RSA key generation failed: {e}")
        raise

def rsa_sign(private_key: rsa.RSAPrivateKey, data: bytes) -> bytes:
    """Sign data with RSA using SHA-256."""
    try:
        return private_key.sign(data, padding.PKCS1v15(), hashes.SHA256())
    except Exception as e:
        logger.error(f"RSA sign failed: {e}")
        raise

def rsa_verify(public_key: rsa.RSAPublicKey, signature: bytes, data: bytes) -> bool:
    """Verify RSA signature."""
    try:
        public_key.verify(signature, data, padding.PKCS1v15(), hashes.SHA256())
        return True
    except Exception as e:
        logger.warning(f"RSA verify failed: {e}")
        return False

def rsa_encrypt(public_key: rsa.RSAPublicKey, data: bytes) -> bytes:
    """Encrypt data with RSA using OAEP."""
    try:
        return public_key.encrypt(
            data,
            padding.OAEP(
                mgf=padding.MGF1(hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None,
(dry-run)

Changes for .\greenwire\core\emv_generator.py:
--- original excerpt ---
"""Utility functions for generating sample EMV card data."""

import random
import secrets
from datetime import datetime, timedelta, UTC


def _luhn_checksum(number: str) -> int:
    digits = [int(d) for d in number]
    checksum = 0
    parity = len(digits) % 2
    for i, digit in enumerate(digits):
        if i % 2 == parity:
            digit *= 2
            if digit > 9:
                digit -= 9
        checksum += digit
    return checksum % 10


def luhn_validate(number: str) -> bool:
    """Return True if the provided number passes the Luhn check."""
    return _luhn_checksum(number) == 0


def _calculate_luhn_digit(number: str) -> str:
    """Return the Luhn check digit for the given number string."""
    check = _luhn_checksum(number + "0")
    return str((10 - check) % 10)


def random_pan(iin: str = "400000") -> str:
    """Generate a random 16-digit PAN using the provided IIN prefix."""
    body_length = 15 - len(iin)
    body = iin + ''.join(str(random.randint(0, 9)) for _ in range(body_length))
    check_digit = _calculate_luhn_digit(body)
    return body + check_digit


def random_expiry(years_valid: int = 3) -> str:
    """Return an expiration date in YYMM format some years in the future.

    The current time is taken in UTC to ensure timezone-aware calculations.
    """
    exp = datetime.now(UTC) + timedelta(days=365 * years_valid)
    return exp.strftime("%y%m")


def generate_card(issuer: str = "TEST BANK", iin: str = "400000") -> dict:
    """Generate basic EMV card data with a unique encryption key."""
--- proposed excerpt ---
"""Utility functions for generating sample EMV card data."""

import random, secrets
from datetime import UTC, datetime, timedelta


def _luhn_checksum(number: str) -> int:
    digits = [int(d) for d in number]
    checksum = 0
    parity = len(digits) % 2
    for i, digit in enumerate(digits):
        if i % 2 == parity:
            digit *= 2
            if digit > 9:
                digit -= 9
        checksum += digit
    return checksum % 10


def luhn_validate(number: str) -> bool:
    """Return True if the provided number passes the Luhn check."""
    return _luhn_checksum(number) == 0


def _calculate_luhn_digit(number: str) -> str:
    """Return the Luhn check digit for the given number string."""
    check = _luhn_checksum(number + "0")
    return str((10 - check) % 10)


def random_pan(iin: str = "400000") -> str:
    """Generate a random 16-digit PAN using the provided IIN prefix."""
    body_length = 15 - len(iin)
    body = iin + ''.join(str(random.randint(0, 9)) for _ in range(body_length))
    check_digit = _calculate_luhn_digit(body)
    return body + check_digit


def random_expiry(years_valid: int = 3) -> str:
    """Return an expiration date in YYMM format some years in the future.

    The current time is taken in UTC to ensure timezone-aware calculations.
    """
    exp = datetime.now(UTC) + timedelta(days=365 * years_valid)
    return exp.strftime("%y%m")


def generate_card(issuer: str = "TEST BANK", iin: str = "400000") -> dict:
    """Generate basic EMV card data with a unique encryption key."""
    pan = random_pan(iin)
(dry-run)

Changes for .\greenwire\core\file_fuzzer.py:
--- original excerpt ---
from __future__ import annotations

"""Simple fuzzing helpers for file-based parsers.

These utilities mutate image, binary and text inputs to test parser
robustness. They are lightweight and do not depend on project specific
modules so they can be reused across tools.
"""

from pathlib import Path
from typing import Callable, List, Dict
import random
import io

from PIL import Image


def _mutate_bytes(data: bytes, mutations: int = 1) -> bytes:
    """Flip random bytes in ``data`` several times."""
    arr = bytearray(data)
    for _ in range(mutations):
        if not arr:
            break
        idx = random.randint(0, len(arr) - 1)
        arr[idx] ^= random.randint(0, 255)
    return bytes(arr)


def fuzz_image_file(
    path: Path, iterations: int = 10
) -> List[Dict[str, object]]:
    """Repeatedly corrupt an image file and attempt to parse it.

    Parameters
    ----------
    path:
        Seed image file.
    iterations:
        Number of mutated samples to try.

    Returns
    -------
    list of dict
        Parsing results with success flag and any error messages.
    """
    seed = path.read_bytes()
    results: List[Dict[str, object]] = []
    for i in range(iterations):
        mutated = _mutate_bytes(seed, random.randint(1, 5))
        try:
--- proposed excerpt ---
from __future__ import annotations  # noqa: F401

"""Simple fuzzing helpers for file-based parsers.

These utilities mutate image, binary and text inputs to test parser
robustness. They are lightweight and do not depend on project specific
modules so they can be reused across tools.
"""

from pathlib import Path
from typing import Callable, Dict, List
import io, random

from PIL import Image


def _mutate_bytes(data: bytes, mutations: int = 1) -> bytes:
    """Flip random bytes in ``data`` several times."""
    arr = bytearray(data)
    for _ in range(mutations):
        if not arr:
            break
        idx = random.randint(0, len(arr) - 1)
        arr[idx] ^= random.randint(0, 255)
    return bytes(arr)


def fuzz_image_file(
    path: Path, iterations: int = 10
) -> List[Dict[str, object]]:
    """Repeatedly corrupt an image file and attempt to parse it.

    Parameters
    ----------
    path:
        Seed image file.
    iterations:
        Number of mutated samples to try.

    Returns
    -------
    list of dict
        Parsing results with success flag and any error messages.
    """
    seed = path.read_bytes()
    results: List[Dict[str, object]] = []
    for i in range(iterations):
        mutated = _mutate_bytes(seed, random.randint(1, 5))
        try:
            img = Image.open(io.BytesIO(mutated))
(dry-run)

Changes for .\greenwire\core\fuzzer.py:
--- original excerpt ---
#!/usr/bin/env python3
"""SmartcardFuzzer: full-featured fuzzing and EMV analysis suite.

Dependencies
------------
- ``pyscard`` for PC/SC communication
- ``nfcpy`` for contactless terminal emulation
- ``cryptography`` and ``pillow`` for crypto and file helpers
- Java 17/Gradle build providing ``JCOPCardManager`` in ``GREENWIRE.jar``
"""

import sys
import json
import logging
from datetime import datetime
import random
from math import log2
from collections import Counter
import sqlite3
import os
import subprocess
import re
from pathlib import Path
from typing import List, Optional, Union
from dataclasses import dataclass

from greenwire.core.nfc_emv import (
    ContactlessEMVTerminal,
    CAPublicKey,
    load_ca_keys,
    DEFAULT_CA_KEYS,
)

DEFAULT_CA_KEYS = {}

# Analysis thresholds for security checks
ANALYSIS_THRESHOLDS = {
    'MIN_ENTROPY': 6.5,            # Minimum entropy for random values
    'MAX_PATTERN_RATIO': 0.1,      # Maximum ratio of repeating patterns
    'MIN_TIMING_DIFF': 0.001,      # Minimum significant timing difference (seconds)
    'MAX_ERROR_RATE': 0.05,        # Maximum acceptable error rate
    'MIN_KEY_STRENGTH': 128,       # Minimum acceptable key strength (bits)
}

# EMV standard definitions
EMV_STANDARDS = {
    'EMV_BOOK2': {
        'version': '4.3',
        'title': 'EMV Book 2 - Security and Key Management',
        'sections': {
--- proposed excerpt ---
#!/usr/bin/env python3
"""SmartcardFuzzer: full-featured fuzzing and EMV analysis suite.

Dependencies
------------
- ``pyscard`` for PC/SC communication
- ``nfcpy`` for contactless terminal emulation
- ``cryptography`` and ``pillow`` for crypto and file helpers
- Java 17/Gradle build providing ``JCOPCardManager`` in ``GREENWIRE.jar``
"""

import json, logging, os, random, re, sqlite3, subprocess, sys
from datetime import datetime
from math import log2
from collections import Counter
from pathlib import Path
from typing import List, Optional, Union
from dataclasses import dataclass

from greenwire.core.nfc_emv import (
    ContactlessEMVTerminal,
    CAPublicKey,
    load_ca_keys,
    DEFAULT_CA_KEYS,
)

DEFAULT_CA_KEYS = {}

# Analysis thresholds for security checks
ANALYSIS_THRESHOLDS = {
    'MIN_ENTROPY': 6.5,            # Minimum entropy for random values
    'MAX_PATTERN_RATIO': 0.1,      # Maximum ratio of repeating patterns
    'MIN_TIMING_DIFF': 0.001,      # Minimum significant timing difference (seconds)
    'MAX_ERROR_RATE': 0.05,        # Maximum acceptable error rate
    'MIN_KEY_STRENGTH': 128,       # Minimum acceptable key strength (bits)
}

# EMV standard definitions
EMV_STANDARDS = {
    'EMV_BOOK2': {
        'version': '4.3',
        'title': 'EMV Book 2 - Security and Key Management',
        'sections': {
            '6.3': 'Card Authentication Methods',
            '6.5': 'Offline PIN Processing',
            '7.2': 'Cryptogram Generation'
        }
    },
    'EMV_BOOK3': {
        'version': '4.3',
(dry-run)

Changes for .\greenwire\core\nfc_emv.py:
--- original excerpt ---
"""Utilities for NFC-based EMV processing using nfcpy."""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass
from typing import Optional, Dict, List, cast

import nfc





DEFAULT_CA_KEYS = {}


@dataclass
class CAPublicKey:
    """Simple container for a certificate authority public key."""

    rid: str
    index: str
    modulus: str
    exponent: str


def load_ca_keys(path: str) -> Dict[str, Dict[str, str]]:
    """Load CA keys from ``path`` or return ``DEFAULT_CA_KEYS`` on failure."""
    try:
        with open(path, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        result = {}
        for scheme_keys in data.values():
            for entry in scheme_keys:
                result[f"{entry['rid']}_{entry['index']}"] = entry
        return result
    except Exception as exc:  # noqa: BLE001
        logging.warning("Failed to load CA keys from %s: %s", path, exc)
        return DEFAULT_CA_KEYS


class NFCEMVProcessor:
    """Perform basic EMV transactions over NFC."""

    def __init__(self, device: str = "usb") -> None:
        self.device = device

    def _connect(self) -> nfc.clf.ContactlessFrontend:
--- proposed excerpt ---
"""Utilities for NFC-based EMV processing using nfcpy."""

from __future__ import annotations  # noqa: F401

import json, logging, nfc
from dataclasses import dataclass
from typing import Dict, List, Optional, cast






DEFAULT_CA_KEYS = {}


@dataclass
class CAPublicKey:
    """Simple container for a certificate authority public key."""

    rid: str
    index: str
    modulus: str
    exponent: str


def load_ca_keys(path: str) -> Dict[str, Dict[str, str]]:
    """Load CA keys from ``path`` or return ``DEFAULT_CA_KEYS`` on failure."""
    try:
        with open(path, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        result = {}
        for scheme_keys in data.values():
            for entry in scheme_keys:
                result[f"{entry['rid']}_{entry['index']}"] = entry
        return result
    except Exception as exc:  # noqa: BLE001
        logging.warning("Failed to load CA keys from %s: %s", path, exc)
        return DEFAULT_CA_KEYS


class NFCEMVProcessor:
    """Perform basic EMV transactions over NFC."""

    def __init__(self, device: str = "usb") -> None:
        self.device = device

    def _connect(self) -> nfc.clf.ContactlessFrontend:
        return nfc.ContactlessFrontend(self.device)

(dry-run)

Changes for .\greenwire\core\nfc_iso.py:
--- original excerpt ---
"""NFC reader/writer helpers for common ISO standards.

These classes provide an in-memory fallback implementation used in the unit
tests, while also exposing methods that utilise ``nfcpy`` when available.  The
goal is to offer simple read/write operations in environments without NFC
hardware and a more advanced interface when a contactless reader is present.
"""

from __future__ import annotations

from contextlib import contextmanager
from typing import Dict, Optional, Sequence
import subprocess

try:  # Optional nfcpy import
    import nfc
except Exception:  # pragma: no cover - nfcpy may not be installed during tests
    nfc = None


class _BaseReaderWriter:
    """Simple in-memory storage for NFC blocks."""

    def __init__(self) -> None:
        self._storage: Dict[int, bytes] = {}
        self.clf: Optional[object] = None  # ContactlessFrontend when available
        self.tag: Optional[object] = None

    def write_block(self, block: int, data: bytes) -> None:
        if not isinstance(block, int):
            raise TypeError("block must be an integer")
        if not isinstance(data, (bytes, bytearray)):
            raise TypeError("data must be bytes")
        if self.tag and hasattr(self.tag, "write_block"):
            try:
                self.tag.write_block(block, bytes(data))
                return
            except Exception:
                pass  # fall back to in-memory
        self._storage[block] = bytes(data)

    def read_block(self, block: int) -> bytes:
        if self.tag and hasattr(self.tag, "read_block"):
            try:
                data = self.tag.read_block(block)
                if isinstance(data, (bytes, bytearray)):
                    return bytes(data)
            except Exception:
                pass
        return self._storage.get(block, b"")
--- proposed excerpt ---
"""NFC reader/writer helpers for common ISO standards.

These classes provide an in-memory fallback implementation used in the unit
tests, while also exposing methods that utilise ``nfcpy`` when available.  The
goal is to offer simple read/write operations in environments without NFC
hardware and a more advanced interface when a contactless reader is present.
"""

from __future__ import annotations  # noqa: F401

from contextlib import contextmanager
from typing import Dict, Optional, Sequence
import subprocess

try:  # Optional nfcpy import
    import nfc
except Exception:  # pragma: no cover - nfcpy may not be installed during tests
    nfc = None


class _BaseReaderWriter:
    """Simple in-memory storage for NFC blocks."""

    def __init__(self) -> None:
        self._storage: Dict[int, bytes] = {}
        self.clf: Optional[object] = None  # ContactlessFrontend when available
        self.tag: Optional[object] = None

    def write_block(self, block: int, data: bytes) -> None:
        if not isinstance(block, int):
            raise TypeError("block must be an integer")
        if not isinstance(data, (bytes, bytearray)):
            raise TypeError("data must be bytes")
        if self.tag and hasattr(self.tag, "write_block"):
            try:
                self.tag.write_block(block, bytes(data))
                return
            except Exception:
                pass  # fall back to in-memory
        self._storage[block] = bytes(data)

    def read_block(self, block: int) -> bytes:
        if self.tag and hasattr(self.tag, "read_block"):
            try:
                data = self.tag.read_block(block)
                if isinstance(data, (bytes, bytearray)):
                    return bytes(data)
            except Exception:
                pass
        return self._storage.get(block, b"")
(dry-run)

Changes for .\greenwire\core\real_world_card_issuer.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Real-World Card Issuer Module
-----------------------------------------

This module provides functionality for generating EMV-compliant payment cards with
real-world bank data, configurable Cardholder Verification Method (CVM) settings,
and customizable risk management parameters.

The RealWorldCardIssuer class loads bank data, merchant categories and card defaults
from external JSON files for better maintainability and separation of concerns.

Key features:
- Creation of EMV-compliant payment cards
- Real bank routing numbers and BIN ranges
- Configurable CVM settings (offline PIN, signature, online PIN, or combinations)
- Customizable risk management settings (very low, low, medium, high)
- Dynamic Data Authentication (DDA) support
- Real merchant category codes (MCC)
- Compatible with real-world payment terminals
- Personalization options for cardholder name, expiry date, preferred bank, etc.
- Multiple output formats (JSON, CSV, text)

The module allows operators to fully customize card settings through both CLI arguments
and an interactive menu, with defaults optimized for offline/signature and very low risk
settings for maximum acceptance.
"""

import os
import json
import random
import hashlib
import secrets
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any, Union

# Import cryptography modules for DDA key generation
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.backends import default_backend

class RealWorldCardIssuer:
    """
    Issues EMV-compliant cards with real bank data and proper CVM/DDA settings.
    
    This class loads data from external JSON files:
    - bank_data.json: Contains real bank routing numbers and BIN ranges
    - merchant_categories.json: Contains real merchant category codes (MCC)
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Real-World Card Issuer Module
-----------------------------------------

This module provides functionality for generating EMV-compliant payment cards with
real-world bank data, configurable Cardholder Verification Method (CVM) settings,
and customizable risk management parameters.

The RealWorldCardIssuer class loads bank data, merchant categories and card defaults
from external JSON files for better maintainability and separation of concerns.

Key features:
- Creation of EMV-compliant payment cards
- Real bank routing numbers and BIN ranges
- Configurable CVM settings (offline PIN, signature, online PIN, or combinations)
- Customizable risk management settings (very low, low, medium, high)
- Dynamic Data Authentication (DDA) support
- Real merchant category codes (MCC)
- Compatible with real-world payment terminals
- Personalization options for cardholder name, expiry date, preferred bank, etc.
- Multiple output formats (JSON, CSV, text)

The module allows operators to fully customize card settings through both CLI arguments
and an interactive menu, with defaults optimized for offline/signature and very low risk
settings for maximum acceptance.
"""

import hashlib, json, logging, os, random, secrets  # noqa: F401
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Dict, List, Optional, Union  # noqa: F401

# Import cryptography modules for DDA key generation
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes, serialization  # noqa: F401
from cryptography.hazmat.backends import default_backend

class RealWorldCardIssuer:
    """
    Issues EMV-compliant cards with real bank data and proper CVM/DDA settings.
    
    This class loads data from external JSON files:
    - bank_data.json: Contains real bank routing numbers and BIN ranges
    - merchant_categories.json: Contains real merchant category codes (MCC)
    - card_defaults.json: Contains default settings for different card schemes
    
    The external data files make it easier to update the information without
    modifying the code directly.
    """
(dry-run)

Changes for .\greenwire\core\symm_analysis.py:
--- original excerpt ---
import math
from typing import List, Dict


def key_entropy(data: bytes) -> float:
    """Calculate Shannon entropy of key bytes."""
    if not data:
        return 0.0
    length = len(data)
    counts = [0] * 256
    for b in data:
        counts[b] += 1
    entropy = 0.0
    for c in counts:
        if c:
            p = c / length
            entropy -= p * math.log2(p)
    return entropy


def weak_key_bits(data: bytes) -> List[int]:
    """Return indexes of bytes with very low or high hamming weight."""
    weak = []
    for i, b in enumerate(data):
        weight = bin(b).count("1")
        if weight <= 2 or weight >= 6:
            weak.append(i)
    return weak


def find_repeating_sequences(data: bytes, min_len: int = 2) -> List[bytes]:
    """Detect simple repeating byte sequences in the key."""
    patterns = []
    length = len(data)
    for seg_len in range(min_len, min(4, length // 2) + 1):
        for i in range(length - seg_len):
            segment = data[i:i + seg_len]
            if data.count(segment) > 1 and segment not in patterns:
                patterns.append(segment)
    return patterns


def analyze_symmetric_key(
    data: bytes, key_type: str, *, min_entropy: float = 3.5
) -> Dict:
    """Analyze symmetric key material and return analysis information."""
    info = {
        "key_length": len(data) * 8,
        "entropy_score": key_entropy(data),
        "potential_weaknesses": []
--- proposed excerpt ---
import math
from typing import Dict, List


def key_entropy(data: bytes) -> float:
    """Calculate Shannon entropy of key bytes."""
    if not data:
        return 0.0
    length = len(data)
    counts = [0] * 256
    for b in data:
        counts[b] += 1
    entropy = 0.0
    for c in counts:
        if c:
            p = c / length
            entropy -= p * math.log2(p)
    return entropy


def weak_key_bits(data: bytes) -> List[int]:
    """Return indexes of bytes with very low or high hamming weight."""
    weak = []
    for i, b in enumerate(data):
        weight = bin(b).count("1")
        if weight <= 2 or weight >= 6:
            weak.append(i)
    return weak


def find_repeating_sequences(data: bytes, min_len: int = 2) -> List[bytes]:
    """Detect simple repeating byte sequences in the key."""
    patterns = []
    length = len(data)
    for seg_len in range(min_len, min(4, length // 2) + 1):
        for i in range(length - seg_len):
            segment = data[i:i + seg_len]
            if data.count(segment) > 1 and segment not in patterns:
                patterns.append(segment)
    return patterns


def analyze_symmetric_key(
    data: bytes, key_type: str, *, min_entropy: float = 3.5
) -> Dict:
    """Analyze symmetric key material and return analysis information."""
    info = {
        "key_length": len(data) * 8,
        "entropy_score": key_entropy(data),
        "potential_weaknesses": []
(dry-run)

Changes for .\greenwire\core\test_crypto_engine.py:
--- original excerpt ---


import sys
import os
import hashlib
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey
from cryptography.hazmat.primitives.asymmetric.ec import (
    EllipticCurvePrivateKey
)
from greenwire.core import crypto_engine

sys.path.insert(0, os.path.abspath(
    os.path.join(os.path.dirname(__file__), '..', '..', '..')
))


def test_generate_rsa_key():
    key = crypto_engine.generate_rsa_key()
    assert isinstance(key, RSAPrivateKey)


def test_rsa_sign_and_verify():
    priv = crypto_engine.generate_rsa_key()
    pub = priv.public_key()
    data = b"test data"
    sig = crypto_engine.rsa_sign(priv, data)
    assert crypto_engine.rsa_verify(pub, sig, data)
    assert not crypto_engine.rsa_verify(pub, sig, b"wrong")


def test_rsa_encrypt_decrypt():
    priv = crypto_engine.generate_rsa_key()
    pub = priv.public_key()
    data = b"secret"
    ct = crypto_engine.rsa_encrypt(pub, data)
    pt = crypto_engine.rsa_decrypt(priv, ct)
    assert pt == data


def test_generate_ec_key():
    key = crypto_engine.generate_ec_key()
    assert isinstance(key, EllipticCurvePrivateKey)


def test_ec_sign_and_verify():
    priv = crypto_engine.generate_ec_key()
    pub = priv.public_key()
    data = b"msg"
    sig = crypto_engine.ec_sign(priv, data)
    assert crypto_engine.ec_verify(pub, sig, data)
--- proposed excerpt ---


import hashlib, os, sys
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey
from cryptography.hazmat.primitives.asymmetric.ec import (
    EllipticCurvePrivateKey
)
from greenwire.core import crypto_engine

sys.path.insert(0, os.path.abspath(
    os.path.join(os.path.dirname(__file__), '..', '..', '..')
))


def test_generate_rsa_key():
    key = crypto_engine.generate_rsa_key()
    assert isinstance(key, RSAPrivateKey)


def test_rsa_sign_and_verify():
    priv = crypto_engine.generate_rsa_key()
    pub = priv.public_key()
    data = b"test data"
    sig = crypto_engine.rsa_sign(priv, data)
    assert crypto_engine.rsa_verify(pub, sig, data)
    assert not crypto_engine.rsa_verify(pub, sig, b"wrong")


def test_rsa_encrypt_decrypt():
    priv = crypto_engine.generate_rsa_key()
    pub = priv.public_key()
    data = b"secret"
    ct = crypto_engine.rsa_encrypt(pub, data)
    pt = crypto_engine.rsa_decrypt(priv, ct)
    assert pt == data


def test_generate_ec_key():
    key = crypto_engine.generate_ec_key()
    assert isinstance(key, EllipticCurvePrivateKey)


def test_ec_sign_and_verify():
    priv = crypto_engine.generate_ec_key()
    pub = priv.public_key()
    data = b"msg"
    sig = crypto_engine.ec_sign(priv, data)
    assert crypto_engine.ec_verify(pub, sig, data)
    assert not crypto_engine.ec_verify(pub, sig, b"bad")

(dry-run)

Changes for .\greenwire\emulator.py:
--- original excerpt ---
#
# GREENWIRE Emulator (emulator.py)
# --------------------------------
# Purpose: Unified emulator for NFC, smartcard, and terminal operations, including ISO 14443, ISO 15693, ISO 18092, and EMV simulation.
# Relative to: Used by GREENWIRE CLI and test suites for protocol simulation, fuzzing, and hardware-in-the-loop testing.
# Protocols: ISO 14443, ISO 15693, ISO 18092, EMV, ISO 7816, PCSC, NFC.
#
# Will move GreenwireEmulator and related functions here

import logging
import random
import time
from greenwire.core.nfc_iso import ISO14443ReaderWriter, ISO15693ReaderWriter, ISO18092ReaderWriter

class UnifiedEmulator:
    """
    Unified emulator for NFC and smartcard operations, including terminal simulation.
    """

    def __init__(self):
        self.log_file = "unified_emulator_log.txt"
        self.comm_log_file = "unified_emulator_communication_log.txt"
        self.nfc_reader = ISO14443ReaderWriter()
        self.smartcard_reader = ISO15693ReaderWriter()
        self.iso18092_reader = ISO18092ReaderWriter()

        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                filename=self.log_file,
                filemode='a',
                format='%(asctime)s - %(levelname)s - %(message)s'
            )

    def simulate_terminal(self, terminal_type, command):
        """
        Simulates a terminal environment and logs the command with its interpretation.

        :param terminal_type: The type of terminal (e.g., "nfc", "smartcard").
        :param command: The APDU command to execute.
        """
        log_msg = f"Simulating terminal '{terminal_type}' | SENT: {command}"
        print(log_msg)
        logging.info(log_msg)
        with open(self.comm_log_file, 'a') as comm_log:
            comm_log.write(f"[{time.asctime()}] {log_msg}\n")

        # Simulate a response
        response = '9000'  # Simulate positive response
        response_log = f"Simulating terminal '{terminal_type}' | RECV: {response}"
--- proposed excerpt ---
#
# GREENWIRE Emulator (emulator.py)
# --------------------------------
# Purpose: Unified emulator for NFC, smartcard, and terminal operations, including ISO 14443, ISO 15693, ISO 18092, and EMV simulation.
# Relative to: Used by GREENWIRE CLI and test suites for protocol simulation, fuzzing, and hardware-in-the-loop testing.
# Protocols: ISO 14443, ISO 15693, ISO 18092, EMV, ISO 7816, PCSC, NFC.
#
# Will move GreenwireEmulator and related functions here

import logging, random, time
from greenwire.core.nfc_iso import ISO14443ReaderWriter, ISO15693ReaderWriter, ISO18092ReaderWriter

class UnifiedEmulator:
    """
    Unified emulator for NFC and smartcard operations, including terminal simulation.
    """

    def __init__(self):
        self.log_file = "unified_emulator_log.txt"
        self.comm_log_file = "unified_emulator_communication_log.txt"
        self.nfc_reader = ISO14443ReaderWriter()
        self.smartcard_reader = ISO15693ReaderWriter()
        self.iso18092_reader = ISO18092ReaderWriter()

        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                filename=self.log_file,
                filemode='a',
                format='%(asctime)s - %(levelname)s - %(message)s'
            )

    def simulate_terminal(self, terminal_type, command):
        """
        Simulates a terminal environment and logs the command with its interpretation.

        :param terminal_type: The type of terminal (e.g., "nfc", "smartcard").
        :param command: The APDU command to execute.
        """
        log_msg = f"Simulating terminal '{terminal_type}' | SENT: {command}"
        print(log_msg)
        logging.info(log_msg)
        with open(self.comm_log_file, 'a') as comm_log:
            comm_log.write(f"[{time.asctime()}] {log_msg}\n")

        # Simulate a response
        response = '9000'  # Simulate positive response
        response_log = f"Simulating terminal '{terminal_type}' | RECV: {response}"
        print(response_log)
        logging.info(response_log)
(dry-run)

Changes for .\greenwire\logger.py:
--- original excerpt ---
"""
Logger and log utilities for .cap file APDU/command exchanges.

This logger is used to track all APDU (command) exchanges with smart cards,
especially for .cap file operations. It provides replay, suspicious activity
detection, and log sealing for audit and debugging.

Layman summary:
- Every command sent to the card and its response is logged.
- Suspicious or fingerprinting commands are detected and flagged.
- You can replay sessions, randomize responses, and seal logs for security.
- All logs are saved as JSON files next to your .cap file.
"""

import os
import json
import time
import hashlib


class CapFileLogger:
    """Logger for .cap file APDU/command exchanges."""

    # APDU command prefixes that are often used for fingerprinting or probing
    # the card
    FINGERPRINTING_APDUS = [
        '80CA',  # GET DATA
        '80CB',  # GET DATA (proprietary)
        '80E2',  # Some proprietary commands
        # Add more as needed
    ]
    # Known AIDs for ghost (test/dummy) applets
    GHOST_APPLET_AIDS = [
        'A00000006203010C99',
        'A00000006203010C98',
        # Add more as needed
    ]

    def __init__(self, cap_file):
        """
        Create a logger for a given .cap file.
        Loads previous logs if they exist.
        """
        self.cap_file = cap_file
        self.log_file = f"{cap_file}.log.json"
        self.entries = []
        self.positive_mode = False
        if os.path.exists(self.log_file):
            with open(self.log_file, "r", encoding="utf-8") as f:
                try:
--- proposed excerpt ---
"""
Logger and log utilities for .cap file APDU/command exchanges.

This logger is used to track all APDU (command) exchanges with smart cards,
especially for .cap file operations. It provides replay, suspicious activity
detection, and log sealing for audit and debugging.

Layman summary:
- Every command sent to the card and its response is logged.
- Suspicious or fingerprinting commands are detected and flagged.
- You can replay sessions, randomize responses, and seal logs for security.
- All logs are saved as JSON files next to your .cap file.
"""

import hashlib, json, os, time


class CapFileLogger:
    """Logger for .cap file APDU/command exchanges."""

    # APDU command prefixes that are often used for fingerprinting or probing
    # the card
    FINGERPRINTING_APDUS = [
        '80CA',  # GET DATA
        '80CB',  # GET DATA (proprietary)
        '80E2',  # Some proprietary commands
        # Add more as needed
    ]
    # Known AIDs for ghost (test/dummy) applets
    GHOST_APPLET_AIDS = [
        'A00000006203010C99',
        'A00000006203010C98',
        # Add more as needed
    ]

    def __init__(self, cap_file):
        """
        Create a logger for a given .cap file.
        Loads previous logs if they exist.
        """
        self.cap_file = cap_file
        self.log_file = f"{cap_file}.log.json"
        self.entries = []
        self.positive_mode = False
        if os.path.exists(self.log_file):
            with open(self.log_file, "r", encoding="utf-8") as f:
                try:
                    self.entries = json.load(f)
                except Exception:
                    self.entries = []
(dry-run)

Changes for .\greenwire\nfc_vuln.py:
--- original excerpt ---
from __future__ import annotations

"""Simple NFC/RFID vulnerability scanning helpers."""

from typing import List, Dict

from greenwire.core.nfc_iso import _BaseReaderWriter

DEFAULT_MIFARE_KEYS: List[bytes] = [
    bytes.fromhex("FFFFFFFFFFFF"),
    bytes.fromhex("000000000000"),
    bytes.fromhex("A0A1A2A3A4A5"),
    bytes.fromhex("B0B1B2B3B4B5"),
]


def _try_key(reader: _BaseReaderWriter, block: int, key: bytes) -> bool:
    try:
        return reader.authenticate(block, key)
    except Exception:
        return False


def scan_nfc_vulnerabilities(
    reader: _BaseReaderWriter,
) -> List[Dict[str, object]]:
    """Check a connected NFC tag for common weaknesses."""
    vulns: List[Dict[str, object]] = []

    found_keys = [
        k.hex()
        for k in DEFAULT_MIFARE_KEYS
        if _try_key(reader, 0, k)
    ]
    if found_keys:
        vulns.append({"type": "DEFAULT_KEY", "keys": found_keys})

    try:
        if reader.read_block(4):
            vulns.append({"type": "UNPROTECTED_BLOCK", "block": 4})
    except Exception:
        pass

    return vulns
--- proposed excerpt ---
from __future__ import annotations  # noqa: F401

"""Simple NFC/RFID vulnerability scanning helpers."""

from typing import Dict, List

from greenwire.core.nfc_iso import _BaseReaderWriter

DEFAULT_MIFARE_KEYS: List[bytes] = [
    bytes.fromhex("FFFFFFFFFFFF"),
    bytes.fromhex("000000000000"),
    bytes.fromhex("A0A1A2A3A4A5"),
    bytes.fromhex("B0B1B2B3B4B5"),
]


def _try_key(reader: _BaseReaderWriter, block: int, key: bytes) -> bool:
    try:
        return reader.authenticate(block, key)
    except Exception:
        return False


def scan_nfc_vulnerabilities(
    reader: _BaseReaderWriter,
) -> List[Dict[str, object]]:
    """Check a connected NFC tag for common weaknesses."""
    vulns: List[Dict[str, object]] = []

    found_keys = [
        k.hex()
        for k in DEFAULT_MIFARE_KEYS
        if _try_key(reader, 0, k)
    ]
    if found_keys:
        vulns.append({"type": "DEFAULT_KEY", "keys": found_keys})

    try:
        if reader.read_block(4):
            vulns.append({"type": "UNPROTECTED_BLOCK", "block": 4})
    except Exception:
        pass

    return vulns
(dry-run)

Changes for .\greenwire\test_logger.py:
--- original excerpt ---
import unittest
from unittest.mock import patch, mock_open, MagicMock
import time
import json

from greenwire.logger import CapFileLogger

class TestCapFileLogger(unittest.TestCase):
    def setUp(self):
        self.cap_file = "test.cap"
        self.log_file = f"{self.cap_file}.log.json"
        self.replay_file = f"{self.cap_file}.replay.json"
        self.suspicious_file = f"{self.cap_file}.suspicious.json"
        self.loghash_file = f"{self.cap_file}.loghash.txt"

    @patch("os.path.exists", return_value=False)
    @patch("builtins.open", new_callable=mock_open)
    def test_init_no_log(self, mock_file, mock_exists):
        logger = CapFileLogger(self.cap_file)
        self.assertEqual(logger.entries, [])
        self.assertFalse(logger.positive_mode)

    @patch("os.path.exists", return_value=True)
    @patch("builtins.open", new_callable=mock_open, read_data='[{"apdu": "00A40400", "response": "9000"}]')
    def test_init_with_log(self, mock_file, mock_exists):
        logger = CapFileLogger(self.cap_file)
        self.assertIsInstance(logger.entries, list)
        self.assertEqual(logger.entries[0]["apdu"], "00A40400")

    @patch("greenwire.logger.CapFileLogger.persist_logs_in_cap")
    @patch("builtins.open", new_callable=mock_open)
    def test_log_and_fingerprinting(self, mock_file, mock_persist):
        logger = CapFileLogger(self.cap_file)
        apdu = "80CA1234"
        response = "6A82"
        with patch.object(logger, "is_fingerprinting_apdu", return_value=True):
            with patch.object(logger, "log_suspicious") as mock_susp:
                logger.log("sent", apdu, response)
                self.assertEqual(logger.entries[-1]["response"], "9000")
                mock_susp.assert_called_once()
        with patch.object(logger, "is_fingerprinting_apdu", return_value=False):
            logger.log("sent", "00A40400", "9000")
            self.assertEqual(logger.entries[-1]["apdu"], "00A40400")

    @patch("builtins.open", new_callable=mock_open)
    def test_set_positive_mode(self, mock_file):
        logger = CapFileLogger(self.cap_file)
        logger.entries = []
        logger.set_positive_mode(True)
        self.assertTrue(logger.positive_mode)
--- proposed excerpt ---
import json, time, unittest  # noqa: F401
from unittest.mock import MagicMock, mock_open, patch

from greenwire.logger import CapFileLogger

class TestCapFileLogger(unittest.TestCase):
    def setUp(self):
        self.cap_file = "test.cap"
        self.log_file = f"{self.cap_file}.log.json"
        self.replay_file = f"{self.cap_file}.replay.json"
        self.suspicious_file = f"{self.cap_file}.suspicious.json"
        self.loghash_file = f"{self.cap_file}.loghash.txt"

    @patch("os.path.exists", return_value=False)
    @patch("builtins.open", new_callable=mock_open)
    def test_init_no_log(self, mock_file, mock_exists):
        logger = CapFileLogger(self.cap_file)
        self.assertEqual(logger.entries, [])
        self.assertFalse(logger.positive_mode)

    @patch("os.path.exists", return_value=True)
    @patch("builtins.open", new_callable=mock_open, read_data='[{"apdu": "00A40400", "response": "9000"}]')
    def test_init_with_log(self, mock_file, mock_exists):
        logger = CapFileLogger(self.cap_file)
        self.assertIsInstance(logger.entries, list)
        self.assertEqual(logger.entries[0]["apdu"], "00A40400")

    @patch("greenwire.logger.CapFileLogger.persist_logs_in_cap")
    @patch("builtins.open", new_callable=mock_open)
    def test_log_and_fingerprinting(self, mock_file, mock_persist):
        logger = CapFileLogger(self.cap_file)
        apdu = "80CA1234"
        response = "6A82"
        with patch.object(logger, "is_fingerprinting_apdu", return_value=True):
            with patch.object(logger, "log_suspicious") as mock_susp:
                logger.log("sent", apdu, response)
                self.assertEqual(logger.entries[-1]["response"], "9000")
                mock_susp.assert_called_once()
        with patch.object(logger, "is_fingerprinting_apdu", return_value=False):
            logger.log("sent", "00A40400", "9000")
            self.assertEqual(logger.entries[-1]["apdu"], "00A40400")

    @patch("builtins.open", new_callable=mock_open)
    def test_set_positive_mode(self, mock_file):
        logger = CapFileLogger(self.cap_file)
        logger.entries = []
        logger.set_positive_mode(True)
        self.assertTrue(logger.positive_mode)
        logger.entries = []
        logger.set_positive_mode(False)
(dry-run)

Changes for .\greenwire\tree_menu_cli.py:
--- original excerpt ---
"""Tree-based interactive CLI for GREENWIRE operations.

This script presents a hierarchical menu where the user first selects a
standard/card type and then chooses an action specific to that
selection.  It reuses helpers from ``menu_cli`` and ``crypto_engine``.
"""

from __future__ import annotations

import argparse
from typing import Callable, Dict

from greenwire.core.crypto_engine import generate_rsa_key, generate_ec_key
from greenwire.core.nfc_emv import ContactlessEMVTerminal
from greenwire.core.standards import Standard
from greenwire.menu_cli import (
    dump_atr,
    dump_memory,
    brute_force_pin,
    fuzz_apdu,
    fuzz_transaction,
    scan_for_cards,
    dump_filesystem,
    export_data,
    import_data,
    reset_card,
    detect_card_os,
)
from greenwire.core.backend import init_backend

# ---------------------------------------------------------------------------
# Action implementations
# ---------------------------------------------------------------------------


def _terminal_test() -> None:
    """Perform a minimal EMV transaction as a terminal."""
    terminal = ContactlessEMVTerminal(["A0000000031010"])
    results = terminal.run()
    for res in results:
        print(res)


def _atm_hsm_test() -> None:
    """Placeholder for ATM/HSM specific tests."""
    print("[SIMULATION] Running ATM/HSM test sequence")
    _terminal_test()


def _generate_cert() -> None:
--- proposed excerpt ---
"""Tree-based interactive CLI for GREENWIRE operations.

This script presents a hierarchical menu where the user first selects a
standard/card type and then chooses an action specific to that
selection.  It reuses helpers from ``menu_cli`` and ``crypto_engine``.
"""

from __future__ import annotations  # noqa: F401

import argparse
from typing import Callable, Dict

from greenwire.core.crypto_engine import generate_ec_key, generate_rsa_key
from greenwire.core.nfc_emv import ContactlessEMVTerminal
from greenwire.core.standards import Standard
from greenwire.menu_cli import (
    dump_atr,
    dump_memory,
    brute_force_pin,
    fuzz_apdu,
    fuzz_transaction,
    scan_for_cards,
    dump_filesystem,
    export_data,
    import_data,
    reset_card,
    detect_card_os,
)
from greenwire.core.backend import init_backend

# ---------------------------------------------------------------------------
# Action implementations
# ---------------------------------------------------------------------------


def _terminal_test() -> None:
    """Perform a minimal EMV transaction as a terminal."""
    terminal = ContactlessEMVTerminal(["A0000000031010"])
    results = terminal.run()
    for res in results:
        print(res)


def _atm_hsm_test() -> None:
    """Placeholder for ATM/HSM specific tests."""
    print("[SIMULATION] Running ATM/HSM test sequence")
    _terminal_test()


def _generate_cert() -> None:
(dry-run)

Changes for .\menu_handlers.py:
--- original excerpt ---
# ========================================
# Standard EMV Read & Transaction Handler
# ========================================

def standard_emv_read_transaction_interactive():
    """Perform a standard EMV card read and transaction simulation."""
    print("\n💳 Standard EMV Read & Transaction")
    print("="*40)
    print("This will perform a standard EMV card read and simulate a basic transaction.")
    print("\nSteps:")
    print("  1. Select Payment Application (AID)")
    print("  2. Read application data (records, PAN, expiry)")
    print("  3. Generate transaction cryptogram (ARQC)")
    print("  4. Simulate issuer response (ARPC)")
    print("  5. Complete transaction (TC/AC)")
    try:
        from core.advanced_fuzzing import MemoryExtractionFuzzer
        fuzzer = MemoryExtractionFuzzer(verbose=True, enable_logging=True)
        if not fuzzer.connect_to_card():
            print("❌ Could not connect to card. Running in simulation mode.")
            # Simulate EMV steps
            print("\n[SIMULATION] Selecting AID: A0000000031010 (Visa)")
            time.sleep(0.5)
            print("[SIMULATION] Reading records: PAN=4111 1111 1111 1111, Expiry=12/29")
            time.sleep(0.5)
            print("[SIMULATION] Generating ARQC: 8A7F2B1C...")
            time.sleep(0.5)
            print("[SIMULATION] Simulating issuer response: ARPC=9F7A3C...")
            time.sleep(0.5)
            print("[SIMULATION] Completing transaction: TC=6B2E... (APPROVED)")
            print("\n✅ Standard EMV transaction simulation complete.")
        else:
            print("✅ Connected to card. Running real EMV read/transaction...")
            # Example: select AID, read records, generate ARQC, etc.
            # For now, simulate with placeholder steps
            print("Selecting AID: A0000000031010 (Visa)")
            time.sleep(0.5)
            print("Reading records: PAN=4111 1111 1111 1111, Expiry=12/29")
            time.sleep(0.5)
            print("Generating ARQC: 8A7F2B1C...")
            time.sleep(0.5)
            print("Simulating issuer response: ARPC=9F7A3C...")
            time.sleep(0.5)
            print("Completing transaction: TC=6B2E... (APPROVED)")
            print("\n✅ Standard EMV transaction complete.")
            fuzzer.disconnect()
    except ImportError:
        print("❌ EMV module not available. Simulation only.")
    except Exception as e:
        print(f"❌ Error: {e}")
--- proposed excerpt ---
# ========================================
# Standard EMV Read & Transaction Handler
# ========================================

def standard_emv_read_transaction_interactive():
    """Perform a standard EMV card read and transaction simulation."""
    print("\n💳 Standard EMV Read & Transaction")
    print("="*40)
    print("This will perform a standard EMV card read and simulate a basic transaction.")
    print("\nSteps:")
    print("  1. Select Payment Application (AID)")
    print("  2. Read application data (records, PAN, expiry)")
    print("  3. Generate transaction cryptogram (ARQC)")
    print("  4. Simulate issuer response (ARPC)")
    print("  5. Complete transaction (TC/AC)")
    try:
        from core.advanced_fuzzing import MemoryExtractionFuzzer
        fuzzer = MemoryExtractionFuzzer(verbose=True, enable_logging=True)
        if not fuzzer.connect_to_card():
            print("❌ Could not connect to card. Running in simulation mode.")
            # Simulate EMV steps
            print("\n[SIMULATION] Selecting AID: A0000000031010 (Visa)")
            time.sleep(0.5)
            print("[SIMULATION] Reading records: PAN=4111 1111 1111 1111, Expiry=12/29")
            time.sleep(0.5)
            print("[SIMULATION] Generating ARQC: 8A7F2B1C...")
            time.sleep(0.5)
            print("[SIMULATION] Simulating issuer response: ARPC=9F7A3C...")
            time.sleep(0.5)
            print("[SIMULATION] Completing transaction: TC=6B2E... (APPROVED)")
            print("\n✅ Standard EMV transaction simulation complete.")
        else:
            print("✅ Connected to card. Running real EMV read/transaction...")
            # Example: select AID, read records, generate ARQC, etc.
            # For now, simulate with placeholder steps
            print("Selecting AID: A0000000031010 (Visa)")
            time.sleep(0.5)
            print("Reading records: PAN=4111 1111 1111 1111, Expiry=12/29")
            time.sleep(0.5)
            print("Generating ARQC: 8A7F2B1C...")
            time.sleep(0.5)
            print("Simulating issuer response: ARPC=9F7A3C...")
            time.sleep(0.5)
            print("Completing transaction: TC=6B2E... (APPROVED)")
            print("\n✅ Standard EMV transaction complete.")
            fuzzer.disconnect()
    except ImportError:
        print("❌ EMV module not available. Simulation only.")
    except Exception as e:
        print(f"❌ Error: {e}")
(dry-run)

Changes for .\menu_implementations.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Simplified Menu Handlers
Working implementations using standard Python libraries and existing tools
"""

import os
import sys
import subprocess
import json
import time
import binascii
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any

# Import adb_cmd helper from greenwire
try:
    from greenwire import adb_cmd
    ADB_HELPER_AVAILABLE = True
except ImportError:
    # Fallback to standard subprocess for ADB operations
    ADB_HELPER_AVAILABLE = False

# Standard smartcard imports
try:
    from smartcard.System import readers
    from smartcard.util import toHexString, toBytes
    from smartcard.CardConnection import CardConnection
    from smartcard.Exceptions import CardConnectionException
    PYSCARD_AVAILABLE = True
except ImportError:
    PYSCARD_AVAILABLE = False
    print("⚠️ pyscard not available. Install with: pip install pyscard")

# Basic logging setup
import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class SmartCardManager:
    """Simplified smartcard manager using standard pyscard library."""
    
    def __init__(self):
        self.connection = None
        self.reader = None
    
    def get_readers(self) -> List[str]:
        """Get list of available smartcard readers."""
        if not PYSCARD_AVAILABLE:
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Simplified Menu Handlers
Working implementations using standard Python libraries and existing tools
"""

import binascii, json, logging, os, subprocess, sys, time  # noqa: F401
from pathlib import Path
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple  # noqa: F401

# Import adb_cmd helper from greenwire
try:
    from greenwire import adb_cmd
    ADB_HELPER_AVAILABLE = True
except ImportError:
    # Fallback to standard subprocess for ADB operations
    ADB_HELPER_AVAILABLE = False

# Standard smartcard imports
try:
    from smartcard.System import readers
    from smartcard.util import toHexString, toBytes
    from smartcard.CardConnection import CardConnection
    from smartcard.Exceptions import CardConnectionException
    PYSCARD_AVAILABLE = True
except ImportError:
    PYSCARD_AVAILABLE = False
    print("⚠️ pyscard not available. Install with: pip install pyscard")

# Basic logging setup
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class SmartCardManager:
    """Simplified smartcard manager using standard pyscard library."""
    
    def __init__(self):
        self.connection = None
        self.reader = None
    
    def get_readers(self) -> List[str]:
        """Get list of available smartcard readers."""
        if not PYSCARD_AVAILABLE:
            return []
        try:
            return [str(reader) for reader in readers()]
        except Exception as e:
            logger.error(f"Error getting readers: {e}")
            return []
(dry-run)

Changes for .\modules\android_nfc.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Android NFC Interface
===============================

Interface for using Android device NFC capabilities via ADB for card scanning,
reading, and writing operations. This module allows GREENWIRE to use an Android
phone as an NFC reader/writer through the Android Debug Bridge.

Real-world NFC operations using actual Android hardware.
"""

import os
import sys
import time
import json
import subprocess
import logging
from typing import Optional, Dict, List, Union, Tuple
from pathlib import Path

try:
    from .greenwire_protocol_logger import ProtocolLogger
except ImportError:
    # Fallback if running standalone
    sys.path.append(os.path.dirname(__file__))
    from greenwire_protocol_logger import ProtocolLogger


class AndroidNFCInterface:
    """Interface for Android NFC operations via ADB."""
    
    def __init__(self, device_id: Optional[str] = None, timeout: int = 30, verbose: bool = True):
        self.device_id = device_id
        self.timeout = timeout
        self.verbose = verbose
        self.logger = self._setup_logging()
        self._connected_device = None
        
        # Initialize protocol logger for verbose operations (default enabled)
        if verbose:
            self.protocol_logger = ProtocolLogger(enable_console=True)
            self.logger.info("📊 Human-readable NFC logging enabled by default")
        else:
            self.protocol_logger = None
        
        # Check if ADB is available
        if not self._check_adb_available():
            raise RuntimeError("ADB not available - install Android SDK Platform Tools")
            
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Android NFC Interface
===============================

Interface for using Android device NFC capabilities via ADB for card scanning,
reading, and writing operations. This module allows GREENWIRE to use an Android
phone as an NFC reader/writer through the Android Debug Bridge.

Real-world NFC operations using actual Android hardware.
"""

import json, logging, os, subprocess, sys, time  # noqa: F401
from typing import Dict, List, Optional, Tuple, Union  # noqa: F401
from pathlib import Path  # noqa: F401

try:
    from .greenwire_protocol_logger import ProtocolLogger
except ImportError:
    # Fallback if running standalone
    sys.path.append(os.path.dirname(__file__))
    from greenwire_protocol_logger import ProtocolLogger


class AndroidNFCInterface:
    """Interface for Android NFC operations via ADB."""
    
    def __init__(self, device_id: Optional[str] = None, timeout: int = 30, verbose: bool = True):
        self.device_id = device_id
        self.timeout = timeout
        self.verbose = verbose
        self.logger = self._setup_logging()
        self._connected_device = None
        
        # Initialize protocol logger for verbose operations (default enabled)
        if verbose:
            self.protocol_logger = ProtocolLogger(enable_console=True)
            self.logger.info("📊 Human-readable NFC logging enabled by default")
        else:
            self.protocol_logger = None
        
        # Check if ADB is available
        if not self._check_adb_available():
            raise RuntimeError("ADB not available - install Android SDK Platform Tools")
            
        # Auto-detect device if not specified
        if not self.device_id:
            self.device_id = self._auto_detect_device()
            
        # Verify device connection and NFC capability
(dry-run)

Changes for .\modules\atm_emulator.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
ATM Emulator
------------

Provides a simple ATM emulator that orchestrates a minimal EMV withdrawal
interaction using the EMVTerminalFlow helper.

This is an MVP to exercise hardware and baseline flows; it is intentionally
conservative and focuses on command sequencing, not issuer risk engines.
"""

from typing import Optional, Dict

from emv_data.terminal_flows import EMVTerminalFlow


class ATMEmulator:
    def __init__(self, reader: Optional[str] = None, verbose: bool = False):
        self.flow = EMVTerminalFlow(reader=reader, verbose=verbose)

    def list_readers(self):
        return self.flow.list_readers()

    def withdraw(self, amount_cents: int, pin: Optional[str] = None) -> Dict:
        return self.flow.run_withdrawal(amount_cents=amount_cents, pin=pin)


def main():
    import argparse
    parser = argparse.ArgumentParser(description="ATM Emulator")
    parser.add_argument("amount", type=float, help="Withdrawal amount in currency units (e.g., 20.00)")
    parser.add_argument("--reader", help="PC/SC reader name")
    parser.add_argument("--pin", help="PIN to verify (plaintext demo)")
    parser.add_argument("-v", "--verbose", action="store_true")
    args = parser.parse_args()

    emulator = ATMEmulator(reader=args.reader, verbose=args.verbose)
    summary = emulator.withdraw(int(round(args.amount * 100)), pin=args.pin)
    print(summary)


if __name__ == "__main__":
    main()
--- proposed excerpt ---
#!/usr/bin/env python3
"""
ATM Emulator
------------

Provides a simple ATM emulator that orchestrates a minimal EMV withdrawal
interaction using the EMVTerminalFlow helper.

This is an MVP to exercise hardware and baseline flows; it is intentionally
conservative and focuses on command sequencing, not issuer risk engines.
"""

from typing import Dict, Optional

from emv_data.terminal_flows import EMVTerminalFlow


class ATMEmulator:
    def __init__(self, reader: Optional[str] = None, verbose: bool = False):
        self.flow = EMVTerminalFlow(reader=reader, verbose=verbose)

    def list_readers(self):
        return self.flow.list_readers()

    def withdraw(self, amount_cents: int, pin: Optional[str] = None) -> Dict:
        return self.flow.run_withdrawal(amount_cents=amount_cents, pin=pin)


def main():
    import argparse
    parser = argparse.ArgumentParser(description="ATM Emulator")
    parser.add_argument("amount", type=float, help="Withdrawal amount in currency units (e.g., 20.00)")
    parser.add_argument("--reader", help="PC/SC reader name")
    parser.add_argument("--pin", help="PIN to verify (plaintext demo)")
    parser.add_argument("-v", "--verbose", action="store_true")
    args = parser.parse_args()

    emulator = ATMEmulator(reader=args.reader, verbose=args.verbose)
    summary = emulator.withdraw(int(round(args.amount * 100)), pin=args.pin)
    print(summary)


if __name__ == "__main__":
    main()
(dry-run)

Changes for .\modules\crypto\__init__.py:
--- original excerpt ---
"""
GREENWIRE Cryptographic Library
===============================
A self-contained cryptographic module for GREENWIRE static distribution.
Provides RSA, AES, hashing, and other cryptographic primitives without external dependencies.

Based on Python's built-in hashlib and implements core cryptographic operations.
"""

__version__ = "1.0.0-greenwire"
__author__ = "GREENWIRE Project"

from .primitives import *
from .rsa import *
from .aes import *
from .hashes import *
from .emv_crypto import *
from .key_manager import *

__all__ = [
    'generate_rsa_keypair',
    'rsa_sign',
    'rsa_verify',
    'rsa_encrypt',
    'rsa_decrypt',
    'aes_encrypt',
    'aes_decrypt',
    'hash_sha256',
    'hash_sha1',
    'hash_md5',
    'secure_random',
    # EMV Cryptographic capabilities
    'EMVCryptoManager',
    'EMVKeyDerivation',
    'EMVApplicationCryptogram',
    'CVNType',
    'KeyDerivationMethod',
    'SessionKeyMethod',
    'VisaCVN10',
    'VisaCVN18',
    'VisaCVN22',
    'MasterCardCVN16',
    'MasterCardCVN17',
    'MasterCardCVN20',
    'MasterCardCVN21',
    'InteracCVN133',
    'create_emv_crypto_manager',
    'demonstrate_emv_capabilities',
    # Key Management & Cracking System
    'KeyManager',
--- proposed excerpt ---
"""
GREENWIRE Cryptographic Library
===============================
A self-contained cryptographic module for GREENWIRE static distribution.
Provides RSA, AES, hashing, and other cryptographic primitives without external dependencies.

Based on Python's built-in hashlib and implements core cryptographic operations.
"""

__version__ = "1.0.0-greenwire"
__author__ = "GREENWIRE Project"

from .primitives import *  # noqa: F401
from .rsa import *  # noqa: F401
from .aes import *  # noqa: F401
from .hashes import *  # noqa: F401
from .emv_crypto import *  # noqa: F401
from .key_manager import *  # noqa: F401

__all__ = [
    'generate_rsa_keypair',
    'rsa_sign',
    'rsa_verify',
    'rsa_encrypt',
    'rsa_decrypt',
    'aes_encrypt',
    'aes_decrypt',
    'hash_sha256',
    'hash_sha1',
    'hash_md5',
    'secure_random',
    # EMV Cryptographic capabilities
    'EMVCryptoManager',
    'EMVKeyDerivation',
    'EMVApplicationCryptogram',
    'CVNType',
    'KeyDerivationMethod',
    'SessionKeyMethod',
    'VisaCVN10',
    'VisaCVN18',
    'VisaCVN22',
    'MasterCardCVN16',
    'MasterCardCVN17',
    'MasterCardCVN20',
    'MasterCardCVN21',
    'InteracCVN133',
    'create_emv_crypto_manager',
    'demonstrate_emv_capabilities',
    # Key Management & Cracking System
    'KeyManager',
(dry-run)

Changes for .\modules\crypto\aes.py:
--- original excerpt ---
"""
GREENWIRE AES Implementation
============================
AES encryption/decryption using Python's built-in Crypto libraries where available,
otherwise falls back to minimal implementation.
"""

import os
from typing import Tuple
from .primitives import pad_pkcs7, unpad_pkcs7, secure_random, EncryptionError

# Try to use pycryptodome/pycrypto if available, otherwise minimal implementation
try:
    from Crypto.Cipher import AES as _AES
    HAS_PYCRYPTO = True
except ImportError:
    try:
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        from cryptography.hazmat.backends import default_backend
        HAS_CRYPTOGRAPHY = True
        HAS_PYCRYPTO = False
    except ImportError:
        HAS_PYCRYPTO = False
        HAS_CRYPTOGRAPHY = False


class AES:
    """GREENWIRE AES wrapper class."""
    
    def __init__(self, key: bytes, mode: str = 'CBC', iv: bytes = None):
        """Initialize AES with key and mode."""
        if len(key) not in [16, 24, 32]:
            raise ValueError("AES key must be 16, 24, or 32 bytes")
        
        self.key = key
        self.mode = mode.upper()
        
        if self.mode == 'CBC':
            if iv is None:
                iv = secure_random(16)
            elif len(iv) != 16:
                raise ValueError("AES-CBC IV must be 16 bytes")
            self.iv = iv
        elif self.mode == 'ECB':
            self.iv = None
        else:
            raise ValueError(f"Unsupported AES mode: {mode}")
    
    def encrypt(self, plaintext: bytes) -> bytes:
        """Encrypt plaintext."""
--- proposed excerpt ---
"""
GREENWIRE AES Implementation
============================
AES encryption/decryption using Python's built-in Crypto libraries where available,
otherwise falls back to minimal implementation.
"""

import os  # noqa: F401
from typing import Tuple
from .primitives import EncryptionError, pad_pkcs7, secure_random, unpad_pkcs7

# Try to use pycryptodome/pycrypto if available, otherwise minimal implementation
try:
    from Crypto.Cipher import AES as _AES
    HAS_PYCRYPTO = True
except ImportError:
    try:
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        from cryptography.hazmat.backends import default_backend
        HAS_CRYPTOGRAPHY = True
        HAS_PYCRYPTO = False
    except ImportError:
        HAS_PYCRYPTO = False
        HAS_CRYPTOGRAPHY = False


class AES:
    """GREENWIRE AES wrapper class."""
    
    def __init__(self, key: bytes, mode: str = 'CBC', iv: bytes = None):
        """Initialize AES with key and mode."""
        if len(key) not in [16, 24, 32]:
            raise ValueError("AES key must be 16, 24, or 32 bytes")
        
        self.key = key
        self.mode = mode.upper()
        
        if self.mode == 'CBC':
            if iv is None:
                iv = secure_random(16)
            elif len(iv) != 16:
                raise ValueError("AES-CBC IV must be 16 bytes")
            self.iv = iv
        elif self.mode == 'ECB':
            self.iv = None
        else:
            raise ValueError(f"Unsupported AES mode: {mode}")
    
    def encrypt(self, plaintext: bytes) -> bytes:
        """Encrypt plaintext."""
(dry-run)

Changes for .\modules\crypto\emv_crypto.py:
--- original excerpt ---
"""EMV Cryptographic Attack Module - Enhanced with PyEMV implementations

This module provides comprehensive EMV cryptographic capabilities based on
production-grade implementations from the PyEMV library. It includes:

- Multiple CVN (Cryptogram Version Number) implementations
- Key derivation methods (Option A/B)  
- Session key derivation algorithms
- Application cryptogram generation
- ARPC (Authorization Response Cryptogram) generation
- Secure messaging capabilities

Supported CVN Classes:
- Visa CVN 10, 18, 22
- MasterCard CVN 16, 17, 20, 21
- Interac CVN 133

Key Features:
- Production-quality EMV cryptographic implementations
- Multiple key derivation methods for comprehensive attack coverage
- Session key algorithms for different card schemes
- ARQC/TC/AAC generation capabilities
- ARPC validation and generation
- Secure messaging for script integrity and confidentiality

Usage:
    from modules.crypto.emv_crypto import EMVCryptoManager
    
    # Initialize with issuer master keys
    crypto = EMVCryptoManager(iss_mk_ac, iss_mk_smi, iss_mk_smc)
    
    # Generate CVN-specific implementations
    visa_cvn10 = crypto.get_visa_cvn10(pan, psn)
    mc_cvn16 = crypto.get_mastercard_cvn16(pan, psn)
    
    # Generate cryptograms
    arqc = visa_cvn10.generate_ac(tag_data...)
    arpc = visa_cvn10.generate_arpc(arqc, response_code)
"""

import hashlib
import binascii
import struct
import secrets
from typing import Optional, Union, Tuple, Dict, Any
from enum import Enum
import logging

# Import GREENWIRE crypto primitives
from .primitives import xor_bytes, encrypt_tdes_ecb, adjust_key_parity
--- proposed excerpt ---
"""EMV Cryptographic Attack Module - Enhanced with PyEMV implementations

This module provides comprehensive EMV cryptographic capabilities based on
production-grade implementations from the PyEMV library. It includes:

- Multiple CVN (Cryptogram Version Number) implementations
- Key derivation methods (Option A/B)  
- Session key derivation algorithms
- Application cryptogram generation
- ARPC (Authorization Response Cryptogram) generation
- Secure messaging capabilities

Supported CVN Classes:
- Visa CVN 10, 18, 22
- MasterCard CVN 16, 17, 20, 21
- Interac CVN 133

Key Features:
- Production-quality EMV cryptographic implementations
- Multiple key derivation methods for comprehensive attack coverage
- Session key algorithms for different card schemes
- ARQC/TC/AAC generation capabilities
- ARPC validation and generation
- Secure messaging for script integrity and confidentiality

Usage:
    from modules.crypto.emv_crypto import EMVCryptoManager
    
    # Initialize with issuer master keys
    crypto = EMVCryptoManager(iss_mk_ac, iss_mk_smi, iss_mk_smc)
    
    # Generate CVN-specific implementations
    visa_cvn10 = crypto.get_visa_cvn10(pan, psn)
    mc_cvn16 = crypto.get_mastercard_cvn16(pan, psn)
    
    # Generate cryptograms
    arqc = visa_cvn10.generate_ac(tag_data...)
    arpc = visa_cvn10.generate_arpc(arqc, response_code)
"""

import binascii, hashlib, logging, secrets, struct  # noqa: F401
from typing import Any, Dict, Optional, Tuple, Union
from enum import Enum

# Import GREENWIRE crypto primitives
from .primitives import adjust_key_parity, encrypt_tdes_ecb, xor_bytes

logger = logging.getLogger(__name__)


(dry-run)

Changes for .\modules\crypto\hashes.py:
--- original excerpt ---
"""
GREENWIRE Hash Functions
========================
Cryptographic hash functions using Python's built-in hashlib.
"""

import hashlib
import hmac
from typing import Union


def hash_sha256(data: Union[str, bytes]) -> bytes:
    """Compute SHA-256 hash of data."""
    if isinstance(data, str):
        data = data.encode('utf-8')
    return hashlib.sha256(data).digest()


def hash_sha1(data: Union[str, bytes]) -> bytes:
    """Compute SHA-1 hash of data."""
    if isinstance(data, str):
        data = data.encode('utf-8')
    return hashlib.sha1(data).digest()


def hash_md5(data: Union[str, bytes]) -> bytes:
    """Compute MD5 hash of data."""
    if isinstance(data, str):
        data = data.encode('utf-8')
    return hashlib.md5(data).digest()


def hash_sha512(data: Union[str, bytes]) -> bytes:
    """Compute SHA-512 hash of data."""
    if isinstance(data, str):
        data = data.encode('utf-8')
    return hashlib.sha512(data).digest()


def hmac_sha256(key: bytes, data: bytes) -> bytes:
    """Compute HMAC-SHA256 of data with key."""
    return hmac.new(key, data, hashlib.sha256).digest()


def pbkdf2(password: Union[str, bytes], salt: bytes, iterations: int = 10000, key_length: int = 32) -> bytes:
    """Derive key from password using PBKDF2-HMAC-SHA256."""
    if isinstance(password, str):
        password = password.encode('utf-8')
    return hashlib.pbkdf2_hmac('sha256', password, salt, iterations, key_length)
--- proposed excerpt ---
"""
GREENWIRE Hash Functions
========================
Cryptographic hash functions using Python's built-in hashlib.
"""

import hashlib, hmac
from typing import Union


def hash_sha256(data: Union[str, bytes]) -> bytes:
    """Compute SHA-256 hash of data."""
    if isinstance(data, str):
        data = data.encode('utf-8')
    return hashlib.sha256(data).digest()


def hash_sha1(data: Union[str, bytes]) -> bytes:
    """Compute SHA-1 hash of data."""
    if isinstance(data, str):
        data = data.encode('utf-8')
    return hashlib.sha1(data).digest()


def hash_md5(data: Union[str, bytes]) -> bytes:
    """Compute MD5 hash of data."""
    if isinstance(data, str):
        data = data.encode('utf-8')
    return hashlib.md5(data).digest()


def hash_sha512(data: Union[str, bytes]) -> bytes:
    """Compute SHA-512 hash of data."""
    if isinstance(data, str):
        data = data.encode('utf-8')
    return hashlib.sha512(data).digest()


def hmac_sha256(key: bytes, data: bytes) -> bytes:
    """Compute HMAC-SHA256 of data with key."""
    return hmac.new(key, data, hashlib.sha256).digest()


def pbkdf2(password: Union[str, bytes], salt: bytes, iterations: int = 10000, key_length: int = 32) -> bytes:
    """Derive key from password using PBKDF2-HMAC-SHA256."""
    if isinstance(password, str):
        password = password.encode('utf-8')
    return hashlib.pbkdf2_hmac('sha256', password, salt, iterations, key_length)
(dry-run)

Changes for .\modules\crypto\key_manager.py:
--- original excerpt ---
"""
GREENWIRE Key Management & Cracking System
==========================================

Comprehensive key extraction, evaluation, storage, and cracking system for keys obtained via:
- CAP file analysis and installation
- GlobalPlatform (GP) operations
- OpenSC smart card operations
- Card dump analysis
- EMV transaction data

Features:
- Multi-source key extraction and validation
- Advanced cracking algorithms (brute force, dictionary, rainbow tables)
- Key derivation and correlation analysis
- EMV-specific key cracking using PyEMV methods
- Persistent key database with metadata
- Performance monitoring and optimization
- CVE vulnerability checks for discovered keys

Based on security research from PyEMV and GlobalPlatform specifications.
"""

import os
import json
import hashlib
import sqlite3
import secrets
import threading
import time
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, asdict
from enum import Enum
import concurrent.futures
from collections import defaultdict

# Cryptographic imports
from cryptography.hazmat.primitives import hashes, hmac
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# GREENWIRE imports
from .emv_crypto import create_emv_crypto_manager, EMVKeyDerivation
from .primitives import encrypt_tdes_ecb, decrypt_tdes_ecb, adjust_key_parity


class KeySource(Enum):
--- proposed excerpt ---
"""
GREENWIRE Key Management & Cracking System
==========================================

Comprehensive key extraction, evaluation, storage, and cracking system for keys obtained via:
- CAP file analysis and installation
- GlobalPlatform (GP) operations
- OpenSC smart card operations
- Card dump analysis
- EMV transaction data

Features:
- Multi-source key extraction and validation
- Advanced cracking algorithms (brute force, dictionary, rainbow tables)
- Key derivation and correlation analysis
- EMV-specific key cracking using PyEMV methods
- Persistent key database with metadata
- Performance monitoring and optimization
- CVE vulnerability checks for discovered keys

Based on security research from PyEMV and GlobalPlatform specifications.
"""

import concurrent.futures, hashlib, json, logging, os, secrets, sqlite3, threading, time  # noqa: F401
from datetime import datetime, timedelta  # noqa: F401
from pathlib import Path  # noqa: F401
from typing import Any, Dict, List, Optional, Set, Tuple  # noqa: F401
from dataclasses import asdict, dataclass  # noqa: F401
from enum import Enum
from collections import defaultdict

# Cryptographic imports
from cryptography.hazmat.primitives import hashes, hmac  # noqa: F401
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes  # noqa: F401
from cryptography.hazmat.backends import default_backend  # noqa: F401

# GREENWIRE imports
from .emv_crypto import EMVKeyDerivation, create_emv_crypto_manager
from .primitives import adjust_key_parity, decrypt_tdes_ecb, encrypt_tdes_ecb  # noqa: F401


class KeySource(Enum):
    """Sources of key extraction"""
    CAP_FILE = "cap_file"
    GLOBALPLATFORM = "globalplatform"
    OPENSC = "opensc"
    CARD_DUMP = "card_dump"
    EMV_TRANSACTION = "emv_transaction"
    MERCHANT_TERMINAL = "merchant_terminal"
    BRUTE_FORCE = "brute_force"
(dry-run)

Changes for .\modules\crypto\primitives.py:
--- original excerpt ---
"""
GREENWIRE Cryptographic Primitives
===================================
Core cryptographic functions and utilities.
"""

import os
import secrets
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend


def secure_random(length: int = 16) -> bytes:
    """Generate cryptographically secure random bytes."""
    return secrets.token_bytes(length)


def xor_bytes(a: bytes, b: bytes) -> bytes:
    """XOR two byte arrays of equal length."""
    if len(a) != len(b):
        raise ValueError("Byte arrays must be of equal length")
    return bytes(x ^ y for x, y in zip(a, b))


def pad_pkcs7(data: bytes, block_size: int = 16) -> bytes:
    """Apply PKCS#7 padding to data."""
    padding_length = block_size - (len(data) % block_size)
    padding = bytes([padding_length] * padding_length)
    return data + padding


def unpad_pkcs7(data: bytes, block_size: int = 16) -> bytes:
    """Remove PKCS#7 padding from data."""
    if len(data) == 0 or len(data) % block_size != 0:
        raise ValueError("Invalid padded data length")
    
    padding_length = data[-1]
    if padding_length < 1 or padding_length > block_size:
        raise ValueError("Invalid padding length")
    
    # Verify padding is correct
    for i in range(padding_length):
        if data[-(i + 1)] != padding_length:
            raise ValueError("Invalid padding")
    
    return data[:-padding_length]


def bytes_to_hex(data: bytes) -> str:
    """Convert bytes to hex string."""
--- proposed excerpt ---
"""
GREENWIRE Cryptographic Primitives
===================================
Core cryptographic functions and utilities.
"""

import os, secrets  # noqa: F401
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend


def secure_random(length: int = 16) -> bytes:
    """Generate cryptographically secure random bytes."""
    return secrets.token_bytes(length)


def xor_bytes(a: bytes, b: bytes) -> bytes:
    """XOR two byte arrays of equal length."""
    if len(a) != len(b):
        raise ValueError("Byte arrays must be of equal length")
    return bytes(x ^ y for x, y in zip(a, b))


def pad_pkcs7(data: bytes, block_size: int = 16) -> bytes:
    """Apply PKCS#7 padding to data."""
    padding_length = block_size - (len(data) % block_size)
    padding = bytes([padding_length] * padding_length)
    return data + padding


def unpad_pkcs7(data: bytes, block_size: int = 16) -> bytes:
    """Remove PKCS#7 padding from data."""
    if len(data) == 0 or len(data) % block_size != 0:
        raise ValueError("Invalid padded data length")
    
    padding_length = data[-1]
    if padding_length < 1 or padding_length > block_size:
        raise ValueError("Invalid padding length")
    
    # Verify padding is correct
    for i in range(padding_length):
        if data[-(i + 1)] != padding_length:
            raise ValueError("Invalid padding")
    
    return data[:-padding_length]


def bytes_to_hex(data: bytes) -> str:
    """Convert bytes to hex string."""
    return data.hex().upper()
(dry-run)

Changes for .\modules\crypto\rsa.py:
--- original excerpt ---
"""
GREENWIRE RSA Implementation
============================
RSA key generation, signing, verification, encryption, and decryption.
Uses built-in Python libraries where possible.
"""

import random
import math
from typing import Tuple, Optional
from .primitives import secure_random, GreenwireCryptoError, InvalidSignatureError
from .hashes import hash_sha256, hash_sha1


class RSAKey:
    """GREENWIRE RSA Key class."""
    
    def __init__(self, n: int, e: int, d: Optional[int] = None, p: Optional[int] = None, q: Optional[int] = None):
        """Initialize RSA key with components."""
        self.n = n  # Modulus
        self.e = e  # Public exponent
        self.d = d  # Private exponent
        self.p = p  # First prime
        self.q = q  # Second prime
        
        if d is not None:
            self.is_private = True
        else:
            self.is_private = False
    
    def public_key(self):
        """Get the public key component."""
        return RSAKey(self.n, self.e)
    
    def key_size(self) -> int:
        """Get key size in bits."""
        return self.n.bit_length()
    
    def to_pem_public(self) -> str:
        """Convert to PEM format (simplified)."""
        return f"-----BEGIN GREENWIRE RSA PUBLIC KEY-----\nn={hex(self.n)}\ne={hex(self.e)}\n-----END GREENWIRE RSA PUBLIC KEY-----"
    
    def to_pem_private(self) -> str:
        """Convert to PEM format (simplified)."""
        if not self.is_private:
            raise ValueError("Cannot export private key from public key")
        return f"-----BEGIN GREENWIRE RSA PRIVATE KEY-----\nn={hex(self.n)}\ne={hex(self.e)}\nd={hex(self.d)}\n-----END GREENWIRE RSA PRIVATE KEY-----"


def _miller_rabin(n: int, k: int = 5) -> bool:
--- proposed excerpt ---
"""
GREENWIRE RSA Implementation
============================
RSA key generation, signing, verification, encryption, and decryption.
Uses built-in Python libraries where possible.
"""

import math, random
from typing import Optional, Tuple
from .primitives import GreenwireCryptoError, InvalidSignatureError, secure_random  # noqa: F401
from .hashes import hash_sha1, hash_sha256


class RSAKey:
    """GREENWIRE RSA Key class."""
    
    def __init__(self, n: int, e: int, d: Optional[int] = None, p: Optional[int] = None, q: Optional[int] = None):
        """Initialize RSA key with components."""
        self.n = n  # Modulus
        self.e = e  # Public exponent
        self.d = d  # Private exponent
        self.p = p  # First prime
        self.q = q  # Second prime
        
        if d is not None:
            self.is_private = True
        else:
            self.is_private = False
    
    def public_key(self):
        """Get the public key component."""
        return RSAKey(self.n, self.e)
    
    def key_size(self) -> int:
        """Get key size in bits."""
        return self.n.bit_length()
    
    def to_pem_public(self) -> str:
        """Convert to PEM format (simplified)."""
        return f"-----BEGIN GREENWIRE RSA PUBLIC KEY-----\nn={hex(self.n)}\ne={hex(self.e)}\n-----END GREENWIRE RSA PUBLIC KEY-----"
    
    def to_pem_private(self) -> str:
        """Convert to PEM format (simplified)."""
        if not self.is_private:
            raise ValueError("Cannot export private key from public key")
        return f"-----BEGIN GREENWIRE RSA PRIVATE KEY-----\nn={hex(self.n)}\ne={hex(self.e)}\nd={hex(self.d)}\n-----END GREENWIRE RSA PRIVATE KEY-----"


def _miller_rabin(n: int, k: int = 5) -> bool:
    """Miller-Rabin primality test."""
(dry-run)

Changes for .\modules\emulation.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Emulation Module
==========================

Advanced card and terminal emulation for smartcard and NFC testing.
Provides comprehensive emulation capabilities for payment cards, terminals,
and NFC devices with support for multiple protocols and standards.

This module has been extracted from the main GREENWIRE application for 
better modularity and can be run as a separate process when needed.
"""

import os
import sys
import time
import threading
import subprocess
import logging
from typing import Optional, Dict, List, Union
from pathlib import Path
import argparse


class EmulationBase:
    """Base class for all emulation types."""
    
    def __init__(self, emulation_type: str):
        self.emulation_type = emulation_type
        self.is_running = False
        self._stop_event = threading.Event()
        self._thread = None
        self.logger = self._setup_logging()
        
    def _setup_logging(self):
        """Setup logging for the emulation module."""
        logger = logging.getLogger(f'greenwire_emulation_{self.emulation_type}')
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
        return logger
        
    def start(self):
        """Start the emulation in a background thread."""
        if self.is_running:
            self.logger.warning("Emulation already running")
            return False
            
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Emulation Module
==========================

Advanced card and terminal emulation for smartcard and NFC testing.
Provides comprehensive emulation capabilities for payment cards, terminals,
and NFC devices with support for multiple protocols and standards.

This module has been extracted from the main GREENWIRE application for 
better modularity and can be run as a separate process when needed.
"""

import argparse, logging, os, subprocess, sys, threading, time  # noqa: F401
from typing import Dict, List, Optional, Union  # noqa: F401
from pathlib import Path


class EmulationBase:
    """Base class for all emulation types."""
    
    def __init__(self, emulation_type: str):
        self.emulation_type = emulation_type
        self.is_running = False
        self._stop_event = threading.Event()
        self._thread = None
        self.logger = self._setup_logging()
        
    def _setup_logging(self):
        """Setup logging for the emulation module."""
        logger = logging.getLogger(f'greenwire_emulation_{self.emulation_type}')
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
        return logger
        
    def start(self):
        """Start the emulation in a background thread."""
        if self.is_running:
            self.logger.warning("Emulation already running")
            return False
            
        self.is_running = True
        self._stop_event.clear()
        self._thread = threading.Thread(target=self._emulation_loop, daemon=True)
        self._thread.start()
        self.logger.info(f"Started {self.emulation_type} emulation")
        return True
(dry-run)

Changes for .\modules\greenwire_crypto_fuzzer.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Cryptographic Fuzzing & Vulnerability Research Module
==============================================================

Advanced protocol-aware fuzzing engine targeting EMV, smartcard, and NFC vulnerabilities.
Implements timing attack detection, padding oracle analysis, side-channel exploitation,
and comprehensive cryptographic vulnerability assessment.

Research-Based Attack Vectors:
------------------------------
This section lists the primary cryptographic and protocol attack vectors
implemented or targeted by the GREENWIRE fuzzing engine. These vectors are
derived from academic and industry research, and include timing attacks,
padding oracle exploits, RSA vulnerabilities, EMV protocol weaknesses,
side-channel analysis, and wireless relay/MITM attacks.

Compliance with:
- Microsoft Security Bulletin guidance
- NIST SP 800-108 key derivation standards
- EMVCo cryptographic specifications
- Research from padding oracle vulnerability disclosures

Help:
-----
This module exposes the CryptographicFuzzer class and convenience functions
(start_crypto_fuzzing_session, generate_vulnerability_report). Use Python's
built-in help() to inspect usage interactively:

    >>> from greenwire_crypto_fuzzer import CryptographicFuzzer, start_crypto_fuzzing_session
    >>> help(CryptographicFuzzer)
    >>> help(start_crypto_fuzzing_session)

Quick usage pointers:
- Instantiate CryptographicFuzzer(verbose=True) to enable logging.
- Call start_crypto_fuzzing_session({...}) with a target_config to run a session.
- After a session, call generate_vulnerability_report(session_data) to obtain a textual report.

Note: This "Help" section is informational only. Consult docstrings on the individual
classes and functions for more details.
"""

import os
import sys
import time
import random
import struct
import hashlib
import logging
import threading
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Cryptographic Fuzzing & Vulnerability Research Module
==============================================================

Advanced protocol-aware fuzzing engine targeting EMV, smartcard, and NFC vulnerabilities.
Implements timing attack detection, padding oracle analysis, side-channel exploitation,
and comprehensive cryptographic vulnerability assessment.

Research-Based Attack Vectors:
------------------------------
This section lists the primary cryptographic and protocol attack vectors
implemented or targeted by the GREENWIRE fuzzing engine. These vectors are
derived from academic and industry research, and include timing attacks,
padding oracle exploits, RSA vulnerabilities, EMV protocol weaknesses,
side-channel analysis, and wireless relay/MITM attacks.

Compliance with:
- Microsoft Security Bulletin guidance
- NIST SP 800-108 key derivation standards
- EMVCo cryptographic specifications
- Research from padding oracle vulnerability disclosures

Help:
-----
This module exposes the CryptographicFuzzer class and convenience functions
(start_crypto_fuzzing_session, generate_vulnerability_report). Use Python's
built-in help() to inspect usage interactively:

    >>> from greenwire_crypto_fuzzer import CryptographicFuzzer, start_crypto_fuzzing_session
    >>> help(CryptographicFuzzer)
    >>> help(start_crypto_fuzzing_session)

Quick usage pointers:
- Instantiate CryptographicFuzzer(verbose=True) to enable logging.
- Call start_crypto_fuzzing_session({...}) with a target_config to run a session.
- After a session, call generate_vulnerability_report(session_data) to obtain a textual report.

Note: This "Help" section is informational only. Consult docstrings on the individual
classes and functions for more details.
"""

import hashlib, logging, os, random, statistics, struct, sys, threading, time  # noqa: F401
from typing import Any, Dict, List, Optional, Tuple, Union  # noqa: F401
from datetime import datetime, timedelta  # noqa: F401
from pathlib import Path  # noqa: F401
from collections import defaultdict

try:
    from cryptography.hazmat.primitives import hashes, serialization, padding
(dry-run)

Changes for .\modules\greenwire_emv_compliance.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE EMV & NFC Compliance Module
=====================================

Full EMV and NFC specification compliance with advanced cryptographic support.
Implements EMV contactless specifications, card type detection, and secure data handling.

Compliant with:
- EMVCo EMV Contactless Specifications v2.10
- NFC Forum specifications
- ISO/IEC 14443 Type A/B
- ISO/IEC 18092 (NFC)
- Payment Card Industry (PCI) standards
- Advanced cryptographic methods (ECC, AES, RSA)

Features:
- Precise card type detection (Payment vs. Access cards)
- EMV cryptographic validation
- Dynamic Data Authentication (DDA)
- Static Data Authentication (SDA)
- Comprehensive EMV tag parsing
- NFC protocol compliance
- Security assessment tools
"""

import os
import sys
import time
import logging
import struct
import hashlib
import binascii
from typing import Dict, List, Optional, Union, Tuple, Any
from datetime import datetime
from pathlib import Path

try:
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
    from cryptography.hazmat.backends import default_backend
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

try:
    from .greenwire_protocol_logger import ProtocolLogger
except ImportError:
    # Fallback if running standalone
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE EMV & NFC Compliance Module
=====================================

Full EMV and NFC specification compliance with advanced cryptographic support.
Implements EMV contactless specifications, card type detection, and secure data handling.

Compliant with:
- EMVCo EMV Contactless Specifications v2.10
- NFC Forum specifications
- ISO/IEC 14443 Type A/B
- ISO/IEC 18092 (NFC)
- Payment Card Industry (PCI) standards
- Advanced cryptographic methods (ECC, AES, RSA)

Features:
- Precise card type detection (Payment vs. Access cards)
- EMV cryptographic validation
- Dynamic Data Authentication (DDA)
- Static Data Authentication (SDA)
- Comprehensive EMV tag parsing
- NFC protocol compliance
- Security assessment tools
"""

import binascii, hashlib, logging, os, struct, sys, time  # noqa: F401
from typing import Any, Dict, List, Optional, Tuple, Union  # noqa: F401
from datetime import datetime
from pathlib import Path  # noqa: F401

try:
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
    from cryptography.hazmat.backends import default_backend
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

try:
    from .greenwire_protocol_logger import ProtocolLogger
except ImportError:
    # Fallback if running standalone
    try:
        from greenwire_protocol_logger import ProtocolLogger
    except ImportError:
        ProtocolLogger = None

class EMVCardType:
(dry-run)

Changes for .\modules\greenwire_key_manager.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Cryptographic Key & Certificate Management Module
==========================================================

Advanced cryptographic key and certificate management system with online harvesting,
RSA/ECC key analysis, DDA certificate validation, and CA discovery capabilities.

Features:
- Online key harvesting from public sources
- RSA/ECC key analysis and weakness detection  
- DDA certificate chain validation
- CA certificate discovery and storage
- Cryptographic key database management
- Certificate transparency log monitoring
- Key correlation and pattern analysis
"""

import os
import sys
import json
import time
import hashlib
import sqlite3
import requests
import threading
from typing import Dict, List, Optional, Union, Tuple, Any
from datetime import datetime, timedelta
from pathlib import Path
from urllib.parse import urlparse

try:
    from cryptography import x509
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa, ec
    from cryptography.hazmat.backends import default_backend
    import cryptography.exceptions
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

try:
    from .greenwire_protocol_logger import ProtocolLogger
except ImportError:
    ProtocolLogger = None

class CryptoKeyManager:
    """
    Advanced cryptographic key and certificate management system.
    
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Cryptographic Key & Certificate Management Module
==========================================================

Advanced cryptographic key and certificate management system with online harvesting,
RSA/ECC key analysis, DDA certificate validation, and CA discovery capabilities.

Features:
- Online key harvesting from public sources
- RSA/ECC key analysis and weakness detection  
- DDA certificate chain validation
- CA certificate discovery and storage
- Cryptographic key database management
- Certificate transparency log monitoring
- Key correlation and pattern analysis
"""

import hashlib, json, os, requests, sqlite3, sys, threading, time  # noqa: F401
from typing import Any, Dict, List, Optional, Tuple, Union  # noqa: F401
from datetime import datetime, timedelta
from pathlib import Path  # noqa: F401
from urllib.parse import urlparse  # noqa: F401

try:
    from cryptography import x509
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa, ec
    from cryptography.hazmat.backends import default_backend
    import cryptography.exceptions
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

try:
    from .greenwire_protocol_logger import ProtocolLogger
except ImportError:
    ProtocolLogger = None

class CryptoKeyManager:
    """
    Advanced cryptographic key and certificate management system.
    
    Provides comprehensive key harvesting, analysis, and storage capabilities
    for EMV, RSA, ECC, and CA certificate management.
    """
    
    def __init__(self, db_path: str = "greenwire_crypto_keys.db", verbose: bool = True):
        """Initialize the crypto key manager."""
        self.db_path = db_path
(dry-run)

Changes for .\modules\greenwire_log_viewer.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Log Viewer - Human-readable analysis of protocol logs
Provides operator-friendly viewing of NFC, ATR, and APDU logs
"""

import json
import argparse
import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional

class LogViewer:
    """Human-readable log analysis and reporting tool."""
    
    def __init__(self, log_dir: str = "logs"):
        self.log_dir = Path(log_dir)
        
    def list_sessions(self) -> List[Dict]:
        """List all available log sessions."""
        sessions = []
        
        # Find all session summary files
        for summary_file in self.log_dir.glob("session_summary_*.json"):
            try:
                with open(summary_file, 'r') as f:
                    session_data = json.load(f)
                sessions.append(session_data)
            except Exception as e:
                print(f"Warning: Could not read {summary_file}: {e}")
                
        # Sort by session ID (timestamp)
        sessions.sort(key=lambda x: x.get('session_id', ''))
        return sessions
        
    def analyze_session(self, session_id: str) -> Dict:
        """Analyze a specific session and provide summary."""
        log_files = {
            'protocol': self.log_dir / f"protocol_{session_id}.log",
            'nfc': self.log_dir / f"nfc_{session_id}.log",
            'atr': self.log_dir / f"atr_{session_id}.log",
            'apdu': self.log_dir / f"apdu_{session_id}.log"
        }
        
        analysis = {
            'session_id': session_id,
            'files': {},
            'statistics': {
                'nfc_transactions': 0,
                'atr_analyses': 0,
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Log Viewer - Human-readable analysis of protocol logs
Provides operator-friendly viewing of NFC, ATR, and APDU logs
"""

import argparse, datetime, json
from pathlib import Path
from typing import Any, Dict, List, Optional  # noqa: F401

class LogViewer:
    """Human-readable log analysis and reporting tool."""
    
    def __init__(self, log_dir: str = "logs"):
        self.log_dir = Path(log_dir)
        
    def list_sessions(self) -> List[Dict]:
        """List all available log sessions."""
        sessions = []
        
        # Find all session summary files
        for summary_file in self.log_dir.glob("session_summary_*.json"):
            try:
                with open(summary_file, 'r') as f:
                    session_data = json.load(f)
                sessions.append(session_data)
            except Exception as e:
                print(f"Warning: Could not read {summary_file}: {e}")
                
        # Sort by session ID (timestamp)
        sessions.sort(key=lambda x: x.get('session_id', ''))
        return sessions
        
    def analyze_session(self, session_id: str) -> Dict:
        """Analyze a specific session and provide summary."""
        log_files = {
            'protocol': self.log_dir / f"protocol_{session_id}.log",
            'nfc': self.log_dir / f"nfc_{session_id}.log",
            'atr': self.log_dir / f"atr_{session_id}.log",
            'apdu': self.log_dir / f"apdu_{session_id}.log"
        }
        
        analysis = {
            'session_id': session_id,
            'files': {},
            'statistics': {
                'nfc_transactions': 0,
                'atr_analyses': 0,
                'apdu_exchanges': 0,
                'errors': 0
(dry-run)

Changes for .\modules\greenwire_protocol_logger.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Protocol Logger - Comprehensive logging for NFC and ATR operations
Provides operator-readable verbose logging with protocol-level details
"""

import os
import time
import datetime
import json
import logging
from typing import Dict, List, Any, Optional, Union
from pathlib import Path

class ProtocolLogger:
    """Comprehensive protocol logger for NFC and card operations."""
    
    def __init__(self, log_dir: str = None, enable_console: bool = True):
        """Initialize protocol logger.
        
        Args:
            log_dir: Directory for log files (default: ./logs)
            enable_console: Enable console output
        """
        self.log_dir = Path(log_dir or "logs")
        self.log_dir.mkdir(exist_ok=True)
        self.enable_console = enable_console
        
        # Create structured log files
        self.session_id = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.setup_loggers()
        
    def setup_loggers(self):
        """Setup specialized loggers for different protocol types."""
        # Main protocol logger
        self.protocol_logger = logging.getLogger(f"greenwire_protocol_{self.session_id}")
        self.protocol_logger.setLevel(logging.DEBUG)
        
        # File handlers
        protocol_file = self.log_dir / f"protocol_{self.session_id}.log"
        nfc_file = self.log_dir / f"nfc_{self.session_id}.log"
        atr_file = self.log_dir / f"atr_{self.session_id}.log"
        apdu_file = self.log_dir / f"apdu_{self.session_id}.log"
        
        # Create formatters
        detailed_formatter = logging.Formatter(
            '%(asctime)s | %(levelname)8s | %(name)s | %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Protocol Logger - Comprehensive logging for NFC and ATR operations
Provides operator-readable verbose logging with protocol-level details
"""

import datetime, json, logging, os, time  # noqa: F401
from typing import Any, Dict, List, Optional, Union  # noqa: F401
from pathlib import Path

class ProtocolLogger:
    """Comprehensive protocol logger for NFC and card operations."""
    
    def __init__(self, log_dir: str = None, enable_console: bool = True):
        """Initialize protocol logger.
        
        Args:
            log_dir: Directory for log files (default: ./logs)
            enable_console: Enable console output
        """
        self.log_dir = Path(log_dir or "logs")
        self.log_dir.mkdir(exist_ok=True)
        self.enable_console = enable_console
        
        # Create structured log files
        self.session_id = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.setup_loggers()
        
    def setup_loggers(self):
        """Setup specialized loggers for different protocol types."""
        # Main protocol logger
        self.protocol_logger = logging.getLogger(f"greenwire_protocol_{self.session_id}")
        self.protocol_logger.setLevel(logging.DEBUG)
        
        # File handlers
        protocol_file = self.log_dir / f"protocol_{self.session_id}.log"
        nfc_file = self.log_dir / f"nfc_{self.session_id}.log"
        atr_file = self.log_dir / f"atr_{self.session_id}.log"
        apdu_file = self.log_dir / f"apdu_{self.session_id}.log"
        
        # Create formatters
        detailed_formatter = logging.Formatter(
            '%(asctime)s | %(levelname)8s | %(name)s | %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        # Protocol file handler
        protocol_handler = logging.FileHandler(protocol_file)
        protocol_handler.setFormatter(detailed_formatter)
        self.protocol_logger.addHandler(protocol_handler)
(dry-run)

Changes for .\modules\greenwire_pyapdu_fuzzer.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE pyAPDUFuzzer Integration

Integrates pyAPDUFuzzer (github.com/petrs/pyAPDUFuzzer) with GREENWIRE's
fuzzing capabilities for enhanced APDU testing targeting JCOP, NXP, and EMV cards.
"""

import sys
import os
import json
import random
import time
import subprocess
import threading
from pathlib import Path
from typing import List, Dict, Optional, Tuple, Any

# Try to import pyAPDUFuzzer components
try:
    # Add pyAPDUFuzzer to path if available
    PYAPDUFUZZER_PATH = os.path.join(os.path.dirname(__file__), '..', 'external', 'pyAPDUFuzzer')
    if os.path.exists(PYAPDUFUZZER_PATH):
        sys.path.insert(0, PYAPDUFUZZER_PATH)
    
    # APDUFuzzer: main fuzzer class providing APDU mutation and execution orchestration.
    # APDU: representation/type for a full APDU response or container (data + SW1/SW2).
    # APDUCommand: representation/type for an APDU command (CLA, INS, P1, P2, Lc, data, Le).
    # CardInterface: abstraction over the physical/virtual smartcard interface used to send APDUs.
    from fuzzer import APDUFuzzer
    from apdu import APDU, APDUCommand
    from card_interface import CardInterface
    HAS_PYAPDUFUZZER = True
except ImportError:
    APDUFuzzer = None
    APDU = None 
    APDUCommand = None
    CardInterface = None
    HAS_PYAPDUFUZZER = False

class GreenwirePyAPDUFuzzer:
    """Enhanced APDU fuzzer integrating pyAPDUFuzzer with GREENWIRE capabilities."""
    
    def __init__(self, verbose=True):
        self.verbose = verbose
        self.fuzzer = None
        self.card_interface = None
        self.target_cards = ["jcop", "nxp", "emv"]
        self.session_data = {
            "start_time": None,
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE pyAPDUFuzzer Integration

Integrates pyAPDUFuzzer (github.com/petrs/pyAPDUFuzzer) with GREENWIRE's
fuzzing capabilities for enhanced APDU testing targeting JCOP, NXP, and EMV cards.
"""

import json, os, random, subprocess, sys, threading, time  # noqa: F401
from pathlib import Path  # noqa: F401
from typing import Any, Dict, List, Optional, Tuple  # noqa: F401

# Try to import pyAPDUFuzzer components
try:
    # Add pyAPDUFuzzer to path if available
    PYAPDUFUZZER_PATH = os.path.join(os.path.dirname(__file__), '..', 'external', 'pyAPDUFuzzer')
    if os.path.exists(PYAPDUFUZZER_PATH):
        sys.path.insert(0, PYAPDUFUZZER_PATH)
    
    # APDUFuzzer: main fuzzer class providing APDU mutation and execution orchestration.
    # APDU: representation/type for a full APDU response or container (data + SW1/SW2).
    # APDUCommand: representation/type for an APDU command (CLA, INS, P1, P2, Lc, data, Le).
    # CardInterface: abstraction over the physical/virtual smartcard interface used to send APDUs.
    from fuzzer import APDUFuzzer
    from apdu import APDU, APDUCommand
    from card_interface import CardInterface
    HAS_PYAPDUFUZZER = True
except ImportError:
    APDUFuzzer = None
    APDU = None 
    APDUCommand = None
    CardInterface = None
    HAS_PYAPDUFUZZER = False

class GreenwirePyAPDUFuzzer:
    """Enhanced APDU fuzzer integrating pyAPDUFuzzer with GREENWIRE capabilities."""
    
    def __init__(self, verbose=True):
        self.verbose = verbose
        self.fuzzer = None
        self.card_interface = None
        self.target_cards = ["jcop", "nxp", "emv"]
        self.session_data = {
            "start_time": None,
            "end_time": None,
            "total_commands": 0,
            "successful_commands": 0,
            "errors": [],
            "vulnerabilities": [],
            "card_responses": []
(dry-run)

Changes for .\modules\merchant_emulator.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
Merchant Emulator
-----------------

Provides a minimal EMV purchase flow using EMVTerminalFlow. This module focuses
on exercising card interactions through PC/SC and validating baseline parsing.
"""

from typing import Optional, Dict

from emv_data.terminal_flows import EMVTerminalFlow


class MerchantEmulator:
    def __init__(self, reader: Optional[str] = None, verbose: bool = False):
        self.flow = EMVTerminalFlow(reader=reader, verbose=verbose)

    def list_readers(self):
        return self.flow.list_readers()

    def purchase(self, amount_cents: int, pin: Optional[str] = None) -> Dict:
        return self.flow.run_purchase(amount_cents=amount_cents, pin=pin)


def main():
    import argparse
    parser = argparse.ArgumentParser(description="Merchant Emulator")
    parser.add_argument("amount", type=float, help="Purchase amount in currency units (e.g., 9.99)")
    parser.add_argument("--reader", help="PC/SC reader name")
    parser.add_argument("--pin", help="PIN to verify (plaintext demo)")
    parser.add_argument("-v", "--verbose", action="store_true")
    args = parser.parse_args()

    emulator = MerchantEmulator(reader=args.reader, verbose=args.verbose)
    summary = emulator.purchase(int(round(args.amount * 100)), pin=args.pin)
    print(summary)


if __name__ == "__main__":
    main()
--- proposed excerpt ---
#!/usr/bin/env python3
"""
Merchant Emulator
-----------------

Provides a minimal EMV purchase flow using EMVTerminalFlow. This module focuses
on exercising card interactions through PC/SC and validating baseline parsing.
"""

from typing import Dict, Optional

from emv_data.terminal_flows import EMVTerminalFlow


class MerchantEmulator:
    def __init__(self, reader: Optional[str] = None, verbose: bool = False):
        self.flow = EMVTerminalFlow(reader=reader, verbose=verbose)

    def list_readers(self):
        return self.flow.list_readers()

    def purchase(self, amount_cents: int, pin: Optional[str] = None) -> Dict:
        return self.flow.run_purchase(amount_cents=amount_cents, pin=pin)


def main():
    import argparse
    parser = argparse.ArgumentParser(description="Merchant Emulator")
    parser.add_argument("amount", type=float, help="Purchase amount in currency units (e.g., 9.99)")
    parser.add_argument("--reader", help="PC/SC reader name")
    parser.add_argument("--pin", help="PIN to verify (plaintext demo)")
    parser.add_argument("-v", "--verbose", action="store_true")
    args = parser.parse_args()

    emulator = MerchantEmulator(reader=args.reader, verbose=args.verbose)
    summary = emulator.purchase(int(round(args.amount * 100)), pin=args.pin)
    print(summary)


if __name__ == "__main__":
    main()
(dry-run)

Changes for .\modules\nfc\__init__.py:
--- original excerpt ---
"""
GREENWIRE NFC Library
=====================
A self-contained NFC library for GREENWIRE static distribution.
Provides NFC communication, card emulation, and protocol handling.
"""

__version__ = "1.0.0-greenwire"
__author__ = "GREENWIRE Project"

from .core import *
from .emulation import *
from .protocols import *

__all__ = [
    'NFCDevice',
    'NFCTarget',
    'EMVEmulator',
    'ISO14443A',
    'APDU',
    'GreenwireNFCError',
]
--- proposed excerpt ---
"""
GREENWIRE NFC Library
=====================
A self-contained NFC library for GREENWIRE static distribution.
Provides NFC communication, card emulation, and protocol handling.
"""

__version__ = "1.0.0-greenwire"
__author__ = "GREENWIRE Project"

from .core import *  # noqa: F401
from .emulation import *  # noqa: F401
from .protocols import *  # noqa: F401

__all__ = [
    'NFCDevice',
    'NFCTarget',
    'EMVEmulator',
    'ISO14443A',
    'APDU',
    'GreenwireNFCError',
]
(dry-run)

Changes for .\modules\nfc\core.py:
--- original excerpt ---
"""
GREENWIRE NFC Core
==================
Core NFC device and communication functionality.
"""

import logging
import time
from typing import Optional, List, Dict, Any
from enum import Enum


class NFCProtocol(Enum):
    """NFC protocol types."""
    ISO14443A = "ISO14443A"
    ISO14443B = "ISO14443B" 
    ISO15693 = "ISO15693"
    FELICA = "FeliCa"


class GreenwireNFCError(Exception):
    """Base exception for GREENWIRE NFC operations."""
    pass


class NFCTarget:
    """Represents an NFC target/card."""
    
    def __init__(self, uid: bytes, protocol: NFCProtocol, atr: Optional[bytes] = None):
        """Initialize NFC target."""
        self.uid = uid
        self.protocol = protocol
        self.atr = atr
        self.connected = False
        self._responses = {}
    
    def __str__(self):
        return f"NFCTarget(uid={self.uid.hex()}, protocol={self.protocol.value})"


class NFCDevice:
    """GREENWIRE NFC device emulator."""
    
    def __init__(self, device_path: str = "greenwire:emulated"):
        """Initialize NFC device."""
        self.device_path = device_path
        self.connected = False
        self.targets = []
        self.logger = logging.getLogger("greenwire_nfc")
    
--- proposed excerpt ---
"""
GREENWIRE NFC Core
==================
Core NFC device and communication functionality.
"""

import logging, time
from typing import Any, Dict, List, Optional  # noqa: F401
from enum import Enum


class NFCProtocol(Enum):
    """NFC protocol types."""
    ISO14443A = "ISO14443A"
    ISO14443B = "ISO14443B" 
    ISO15693 = "ISO15693"
    FELICA = "FeliCa"


class GreenwireNFCError(Exception):
    """Base exception for GREENWIRE NFC operations."""
    pass


class NFCTarget:
    """Represents an NFC target/card."""
    
    def __init__(self, uid: bytes, protocol: NFCProtocol, atr: Optional[bytes] = None):
        """Initialize NFC target."""
        self.uid = uid
        self.protocol = protocol
        self.atr = atr
        self.connected = False
        self._responses = {}
    
    def __str__(self):
        return f"NFCTarget(uid={self.uid.hex()}, protocol={self.protocol.value})"


class NFCDevice:
    """GREENWIRE NFC device emulator."""
    
    def __init__(self, device_path: str = "greenwire:emulated"):
        """Initialize NFC device."""
        self.device_path = device_path
        self.connected = False
        self.targets = []
        self.logger = logging.getLogger("greenwire_nfc")
    
    def open(self):
(dry-run)

Changes for .\modules\nfc\emulation.py:
--- original excerpt ---
"""
GREENWIRE NFC Emulation
=======================
EMV card emulation and testing utilities.
"""

import logging
from typing import Dict, List, Optional, Tuple
from .core import NFCTarget, NFCProtocol
from .protocols import APDU, EMVProtocol


class EMVEmulator:
    """EMV card emulator for testing."""
    
    def __init__(self, card_profile: str = "visa"):
        """Initialize EMV emulator with card profile."""
        self.card_profile = card_profile.lower()
        self.logger = logging.getLogger("greenwire_emv")
        self.emv = EMVProtocol()
        self._initialize_card_data()
    
    def _initialize_card_data(self):
        """Initialize card data based on profile."""
        if self.card_profile == "visa":
            self.aid = EMVProtocol.AIDS['VISA']
            self.pan = "4111111111111111"
            self.expiry = "1225"
            self.cardholder_name = "GREENWIRE TEST CARD"
            self.application_label = "VISA CREDIT"
        elif self.card_profile == "mastercard":
            self.aid = EMVProtocol.AIDS['MASTERCARD'] 
            self.pan = "5555555555554444"
            self.expiry = "1225"
            self.cardholder_name = "GREENWIRE TEST CARD"
            self.application_label = "MASTERCARD"
        elif self.card_profile == "amex":
            self.aid = EMVProtocol.AIDS['AMEX']
            self.pan = "378282246310005"
            self.expiry = "1225"
            self.cardholder_name = "GREENWIRE TEST CARD"
            self.application_label = "AMERICAN EXPRESS"
        else:
            # Default to Visa
            self.aid = EMVProtocol.AIDS['VISA']
            self.pan = "4111111111111111"
            self.expiry = "1225"
            self.cardholder_name = "GREENWIRE TEST CARD"
            self.application_label = "VISA CREDIT"
    
--- proposed excerpt ---
"""
GREENWIRE NFC Emulation
=======================
EMV card emulation and testing utilities.
"""

import logging
from typing import Dict, List, Optional, Tuple  # noqa: F401
from .core import NFCProtocol, NFCTarget
from .protocols import APDU, EMVProtocol


class EMVEmulator:
    """EMV card emulator for testing."""
    
    def __init__(self, card_profile: str = "visa"):
        """Initialize EMV emulator with card profile."""
        self.card_profile = card_profile.lower()
        self.logger = logging.getLogger("greenwire_emv")
        self.emv = EMVProtocol()
        self._initialize_card_data()
    
    def _initialize_card_data(self):
        """Initialize card data based on profile."""
        if self.card_profile == "visa":
            self.aid = EMVProtocol.AIDS['VISA']
            self.pan = "4111111111111111"
            self.expiry = "1225"
            self.cardholder_name = "GREENWIRE TEST CARD"
            self.application_label = "VISA CREDIT"
        elif self.card_profile == "mastercard":
            self.aid = EMVProtocol.AIDS['MASTERCARD'] 
            self.pan = "5555555555554444"
            self.expiry = "1225"
            self.cardholder_name = "GREENWIRE TEST CARD"
            self.application_label = "MASTERCARD"
        elif self.card_profile == "amex":
            self.aid = EMVProtocol.AIDS['AMEX']
            self.pan = "378282246310005"
            self.expiry = "1225"
            self.cardholder_name = "GREENWIRE TEST CARD"
            self.application_label = "AMERICAN EXPRESS"
        else:
            # Default to Visa
            self.aid = EMVProtocol.AIDS['VISA']
            self.pan = "4111111111111111"
            self.expiry = "1225"
            self.cardholder_name = "GREENWIRE TEST CARD"
            self.application_label = "VISA CREDIT"
    
(dry-run)

Changes for .\modules\nfc\protocols.py:
--- original excerpt ---
"""
GREENWIRE NFC Protocols
=======================
Implementation of NFC protocols (ISO14443, etc.).
"""

from typing import Dict, List, Optional, Union
from dataclasses import dataclass
from enum import Enum


class APDUType(Enum):
    """APDU command types."""
    SELECT = "SELECT"
    READ_RECORD = "READ_RECORD" 
    GET_DATA = "GET_DATA"
    VERIFY = "VERIFY"
    GET_CHALLENGE = "GET_CHALLENGE"
    EXTERNAL_AUTHENTICATE = "EXTERNAL_AUTHENTICATE"
    INTERNAL_AUTHENTICATE = "INTERNAL_AUTHENTICATE"
    GENERATE_AC = "GENERATE_AC"
    GET_PROCESSING_OPTIONS = "GET_PROCESSING_OPTIONS"


@dataclass
class APDU:
    """APDU command structure."""
    cla: int  # Class byte
    ins: int  # Instruction byte
    p1: int   # Parameter 1
    p2: int   # Parameter 2
    lc: Optional[int] = None  # Length of command data
    data: Optional[bytes] = None  # Command data
    le: Optional[int] = None  # Expected length of response data
    
    def to_bytes(self) -> bytes:
        """Convert APDU to bytes."""
        result = bytes([self.cla, self.ins, self.p1, self.p2])
        
        if self.data is not None:
            result += bytes([len(self.data)]) + self.data
        elif self.lc is not None:
            result += bytes([self.lc])
        
        if self.le is not None:
            result += bytes([self.le])
        
        return result
    
    @classmethod
--- proposed excerpt ---
"""
GREENWIRE NFC Protocols
=======================
Implementation of NFC protocols (ISO14443, etc.).
"""

from typing import Dict, List, Optional, Union  # noqa: F401
from dataclasses import dataclass
from enum import Enum


class APDUType(Enum):
    """APDU command types."""
    SELECT = "SELECT"
    READ_RECORD = "READ_RECORD" 
    GET_DATA = "GET_DATA"
    VERIFY = "VERIFY"
    GET_CHALLENGE = "GET_CHALLENGE"
    EXTERNAL_AUTHENTICATE = "EXTERNAL_AUTHENTICATE"
    INTERNAL_AUTHENTICATE = "INTERNAL_AUTHENTICATE"
    GENERATE_AC = "GENERATE_AC"
    GET_PROCESSING_OPTIONS = "GET_PROCESSING_OPTIONS"


@dataclass
class APDU:
    """APDU command structure."""
    cla: int  # Class byte
    ins: int  # Instruction byte
    p1: int   # Parameter 1
    p2: int   # Parameter 2
    lc: Optional[int] = None  # Length of command data
    data: Optional[bytes] = None  # Command data
    le: Optional[int] = None  # Expected length of response data
    
    def to_bytes(self) -> bytes:
        """Convert APDU to bytes."""
        result = bytes([self.cla, self.ins, self.p1, self.p2])
        
        if self.data is not None:
            result += bytes([len(self.data)]) + self.data
        elif self.lc is not None:
            result += bytes([self.lc])
        
        if self.le is not None:
            result += bytes([self.le])
        
        return result
    
    @classmethod
(dry-run)

Changes for .\modules\production_crypto_engine.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Production Cryptographic Engine
==========================================

Enhanced cryptographic engine with production-grade capabilities using legitimate
test vectors and keys from EMVCo, payment schemes, and security research sources.

⚠️  SECURITY NOTICE ⚠️
This module uses LEGITIMATE TEST KEYS and VECTORS designed for security research.
These are NOT production keys and should NEVER be used in real payment systems.
All keys and data are sourced from public EMV specifications, academic research,
and authorized test environments.

Features:
- Enhanced CA Keys Database with EMVCo test vectors
- Production-grade DDA/SDA implementations
- Comprehensive merchant database with realistic synthetic data
- Multi-scheme CVN support (Visa, MasterCard, Amex, Discover, JCB)
- Advanced key derivation and validation
- Certificate chain processing
- Real-world transaction simulation

Sources:
- EMVCo EMV 4.3 Book 2 Annex A (Test Keys)
- Visa Global Platform Test Keys
- MasterCard M/Chip Test Vectors
- Academic EMV research papers
- PyEMV reference implementation
- Open-source EMV projects
"""

import os
import sys
import json
import time
import logging
import secrets
import hashlib
import binascii
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Union, Tuple, Any
from dataclasses import dataclass, asdict
from enum import Enum

# Cryptographic imports
try:
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa, padding
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Production Cryptographic Engine
==========================================

Enhanced cryptographic engine with production-grade capabilities using legitimate
test vectors and keys from EMVCo, payment schemes, and security research sources.

⚠️  SECURITY NOTICE ⚠️
This module uses LEGITIMATE TEST KEYS and VECTORS designed for security research.
These are NOT production keys and should NEVER be used in real payment systems.
All keys and data are sourced from public EMV specifications, academic research,
and authorized test environments.

Features:
- Enhanced CA Keys Database with EMVCo test vectors
- Production-grade DDA/SDA implementations
- Comprehensive merchant database with realistic synthetic data
- Multi-scheme CVN support (Visa, MasterCard, Amex, Discover, JCB)
- Advanced key derivation and validation
- Certificate chain processing
- Real-world transaction simulation

Sources:
- EMVCo EMV 4.3 Book 2 Annex A (Test Keys)
- Visa Global Platform Test Keys
- MasterCard M/Chip Test Vectors
- Academic EMV research papers
- PyEMV reference implementation
- Open-source EMV projects
"""

import binascii, hashlib, json, logging, os, secrets, sys, time  # noqa: F401
from datetime import datetime, timedelta
from pathlib import Path  # noqa: F401
from typing import Any, Dict, List, Optional, Tuple, Union  # noqa: F401
from dataclasses import asdict, dataclass
from enum import Enum

# Cryptographic imports
try:
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa, padding
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
    from cryptography.hazmat.backends import default_backend
    from cryptography.exceptions import InvalidSignature
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False

(dry-run)

Changes for .\modules\ui\__init__.py:
--- original excerpt ---
"""
GREENWIRE UI Library
====================
User interface components for GREENWIRE static distribution.
"""

__version__ = "1.0.0-greenwire"
__author__ = "GREENWIRE Project"

from .menu import *
from .colors import *

__all__ = [
    'GreenwireMenu',
    'MenuItem',
    'MenuAction',
    'print_colored',
    'print_banner',
    'Colors',
]
--- proposed excerpt ---
"""
GREENWIRE UI Library
====================
User interface components for GREENWIRE static distribution.
"""

__version__ = "1.0.0-greenwire"
__author__ = "GREENWIRE Project"

from .menu import *  # noqa: F401
from .colors import *  # noqa: F401

__all__ = [
    'GreenwireMenu',
    'MenuItem',
    'MenuAction',
    'print_colored',
    'print_banner',
    'Colors',
]
(dry-run)

Changes for .\modules\ui\colors.py:
--- original excerpt ---
"""
GREENWIRE Color Utilities
=========================
Color output and formatting utilities.
"""

import sys
from typing import Optional


class Colors:
    """ANSI color codes for terminal output."""
    
    # Text colors
    BLACK = '\033[30m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    
    # Bright colors
    BRIGHT_BLACK = '\033[90m'
    BRIGHT_RED = '\033[91m'
    BRIGHT_GREEN = '\033[92m'
    BRIGHT_YELLOW = '\033[93m'
    BRIGHT_BLUE = '\033[94m'
    BRIGHT_MAGENTA = '\033[95m'
    BRIGHT_CYAN = '\033[96m'
    BRIGHT_WHITE = '\033[97m'
    
    # Background colors
    BG_BLACK = '\033[40m'
    BG_RED = '\033[41m'
    BG_GREEN = '\033[42m'
    BG_YELLOW = '\033[43m'
    BG_BLUE = '\033[44m'
    BG_MAGENTA = '\033[45m'
    BG_CYAN = '\033[46m'
    BG_WHITE = '\033[47m'
    
    # Styles
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    UNDERLINE = '\033[4m'
    BLINK = '\033[5m'
    REVERSE = '\033[7m'
--- proposed excerpt ---
"""
GREENWIRE Color Utilities
=========================
Color output and formatting utilities.
"""

import sys
from typing import Optional  # noqa: F401


class Colors:
    """ANSI color codes for terminal output."""
    
    # Text colors
    BLACK = '\033[30m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    
    # Bright colors
    BRIGHT_BLACK = '\033[90m'
    BRIGHT_RED = '\033[91m'
    BRIGHT_GREEN = '\033[92m'
    BRIGHT_YELLOW = '\033[93m'
    BRIGHT_BLUE = '\033[94m'
    BRIGHT_MAGENTA = '\033[95m'
    BRIGHT_CYAN = '\033[96m'
    BRIGHT_WHITE = '\033[97m'
    
    # Background colors
    BG_BLACK = '\033[40m'
    BG_RED = '\033[41m'
    BG_GREEN = '\033[42m'
    BG_YELLOW = '\033[43m'
    BG_BLUE = '\033[44m'
    BG_MAGENTA = '\033[45m'
    BG_CYAN = '\033[46m'
    BG_WHITE = '\033[47m'
    
    # Styles
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    UNDERLINE = '\033[4m'
    BLINK = '\033[5m'
    REVERSE = '\033[7m'
(dry-run)

Changes for .\modules\ui\menu.py:
--- original excerpt ---
"""
GREENWIRE Menu System
=====================
Interactive menu system for GREENWIRE CLI.
"""

import sys
from typing import List, Callable, Optional, Dict, Any
from dataclasses import dataclass
from enum import Enum


class MenuAction(Enum):
    """Menu action types."""
    EXECUTE = "execute"
    SUBMENU = "submenu"
    EXIT = "exit"
    BACK = "back"


@dataclass
class MenuItem:
    """Represents a menu item."""
    key: str
    title: str
    description: str
    action: MenuAction
    handler: Optional[Callable] = None
    submenu: Optional['GreenwireMenu'] = None
    data: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Validate menu item after initialization."""
        if self.action == MenuAction.EXECUTE and self.handler is None:
            raise ValueError(f"Menu item '{self.key}' requires handler for EXECUTE action")
        if self.action == MenuAction.SUBMENU and self.submenu is None:
            raise ValueError(f"Menu item '{self.key}' requires submenu for SUBMENU action")


class GreenwireMenu:
    """GREENWIRE interactive menu system."""
    
    def __init__(self, title: str, description: str = ""):
        """Initialize menu."""
        self.title = title
        self.description = description
        self.items: List[MenuItem] = []
        self.parent: Optional['GreenwireMenu'] = None
        self._running = False
    
--- proposed excerpt ---
"""
GREENWIRE Menu System
=====================
Interactive menu system for GREENWIRE CLI.
"""

import sys  # noqa: F401
from typing import Any, Callable, Dict, List, Optional
from dataclasses import dataclass
from enum import Enum


class MenuAction(Enum):
    """Menu action types."""
    EXECUTE = "execute"
    SUBMENU = "submenu"
    EXIT = "exit"
    BACK = "back"


@dataclass
class MenuItem:
    """Represents a menu item."""
    key: str
    title: str
    description: str
    action: MenuAction
    handler: Optional[Callable] = None
    submenu: Optional['GreenwireMenu'] = None
    data: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Validate menu item after initialization."""
        if self.action == MenuAction.EXECUTE and self.handler is None:
            raise ValueError(f"Menu item '{self.key}' requires handler for EXECUTE action")
        if self.action == MenuAction.SUBMENU and self.submenu is None:
            raise ValueError(f"Menu item '{self.key}' requires submenu for SUBMENU action")


class GreenwireMenu:
    """GREENWIRE interactive menu system."""
    
    def __init__(self, title: str, description: str = ""):
        """Initialize menu."""
        self.title = title
        self.description = description
        self.items: List[MenuItem] = []
        self.parent: Optional['GreenwireMenu'] = None
        self._running = False
    
(dry-run)

Changes for .\setup.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Static Distribution Setup Script

This script creates a static distribution of GREENWIRE with all dependencies
bundled for easy deployment and distribution.
"""

from setuptools import setup, find_packages
import sys
import os
import shutil
from pathlib import Path

# Version information
VERSION = "1.0.0"

# Read requirements
with open('requirements.txt', 'r') as f:
    requirements = [
        line.strip() 
        for line in f.readlines() 
        if line.strip() and not line.startswith('#')
    ]

# Data files to include in the distribution
data_files = [
    ('static/java', ['static/java/gp.jar']),
    ('static/data', [
        'data/bank_data.json',
        'data/merchant_categories.json', 
        'data/card_defaults.json'
    ]),
    ('', ['requirements.txt', 'README.md']),
]

# Additional files to include
package_data = {
    'greenwire': [
        'core/*.py',
        'cli/*.py',
        'data/*.json',
    ]
}

setup(
    name="greenwire-static",
    version=VERSION,
    description="GREENWIRE EMV/NFC Testing Toolkit - Static Distribution",
    long_description=open('README.md', 'r', encoding='utf-8').read(),
--- proposed excerpt ---
#!/usr/bin/env python3
"""
GREENWIRE Static Distribution Setup Script

This script creates a static distribution of GREENWIRE with all dependencies
bundled for easy deployment and distribution.
"""

from setuptools import find_packages, setup
import os, shutil, sys
from pathlib import Path

# Version information
VERSION = "1.0.0"

# Read requirements
with open('requirements.txt', 'r') as f:
    requirements = [
        line.strip() 
        for line in f.readlines() 
        if line.strip() and not line.startswith('#')
    ]

# Data files to include in the distribution
data_files = [
    ('static/java', ['static/java/gp.jar']),
    ('static/data', [
        'data/bank_data.json',
        'data/merchant_categories.json', 
        'data/card_defaults.json'
    ]),
    ('', ['requirements.txt', 'README.md']),
]

# Additional files to include
package_data = {
    'greenwire': [
        'core/*.py',
        'cli/*.py',
        'data/*.json',
    ]
}

setup(
    name="greenwire-static",
    version=VERSION,
    description="GREENWIRE EMV/NFC Testing Toolkit - Static Distribution",
    long_description=open('README.md', 'r', encoding='utf-8').read(),
    long_description_content_type="text/markdown",
    author="GREENWIRE Team",
(dry-run)

Changes for .\test_emv.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
EMV Integration Test Suite
==========================
Test the GREENWIRE EMV data integration modules
"""

import sys
import os

def test_emv_commands():
    """Test EMV commands module"""
    print("Testing EMV Commands module...")
    try:
        from emv_data.commands.emv_commands import EMVCommand, EMV_COMMANDS, get_emv_command, list_emv_commands
        
        # Test basic functionality
        commands = list_emv_commands()
        print(f"✓ Found {len(commands)} EMV commands")
        
        # Test specific command
        select_cmd = get_emv_command("SELECT")
        if select_cmd:
            print(f"✓ SELECT command: {select_cmd.name} - {select_cmd.description}")
        else:
            print("✗ SELECT command not found")
            
        return True
    except Exception as e:
        print(f"✗ EMV Commands module failed: {e}")
        return False

def test_apdu_responses():
    """Test APDU responses module"""
    print("\nTesting APDU Responses module...")
    try:
        from emv_data.commands.apdu_responses import APDUResponse, get_apdu_response, is_success, list_response_codes
        
        # Test basic functionality
        codes = list_response_codes()
        print(f"✓ Found {len(codes)} APDU response codes")
        
        # Test specific response
        success_response = get_apdu_response("9000")
        if success_response:
            print(f"✓ Success response: {success_response.code} - {success_response.description}")
        else:
            print("✗ Success response not found")
            
        # Test success check
--- proposed excerpt ---
#!/usr/bin/env python3
"""
EMV Integration Test Suite
==========================
Test the GREENWIRE EMV data integration modules
"""

import os, sys  # noqa: F401

def test_emv_commands():
    """Test EMV commands module"""
    print("Testing EMV Commands module...")
    try:
        from emv_data.commands.emv_commands import EMVCommand, EMV_COMMANDS, get_emv_command, list_emv_commands
        
        # Test basic functionality
        commands = list_emv_commands()
        print(f"✓ Found {len(commands)} EMV commands")
        
        # Test specific command
        select_cmd = get_emv_command("SELECT")
        if select_cmd:
            print(f"✓ SELECT command: {select_cmd.name} - {select_cmd.description}")
        else:
            print("✗ SELECT command not found")
            
        return True
    except Exception as e:
        print(f"✗ EMV Commands module failed: {e}")
        return False

def test_apdu_responses():
    """Test APDU responses module"""
    print("\nTesting APDU Responses module...")
    try:
        from emv_data.commands.apdu_responses import APDUResponse, get_apdu_response, is_success, list_response_codes
        
        # Test basic functionality
        codes = list_response_codes()
        print(f"✓ Found {len(codes)} APDU response codes")
        
        # Test specific response
        success_response = get_apdu_response("9000")
        if success_response:
            print(f"✓ Success response: {success_response.code} - {success_response.description}")
        else:
            print("✗ Success response not found")
            
        # Test success check
        if is_success("9000"):
(dry-run)

Changes for .\tests\conftest.py:
--- original excerpt ---
"""Test configuration for GREENWIRE project.

This file ensures the project root is available on sys.path so that tests can
import modules using the canonical package names (e.g. ``GREENWIRE.core``).
"""
from __future__ import annotations

import sys
from pathlib import Path

PROJECT_ROOT = Path(__file__).resolve().parents[1]
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))
--- proposed excerpt ---
"""Test configuration for GREENWIRE project.

This file ensures the project root is available on sys.path so that tests can
import modules using the canonical package names (e.g. ``GREENWIRE.core``).
"""
from __future__ import annotations  # noqa: F401

import sys
from pathlib import Path

PROJECT_ROOT = Path(__file__).resolve().parents[1]
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))
(dry-run)

Changes for .\tool_audit.py:
--- original excerpt ---
"""Minimal environment audit for GREENWIRE.

Provides aggregate(), human(), check_readiness(), and main() used by greenwire.py.
Checks: java, adb, gp.jar presence and version where applicable.
"""
from __future__ import annotations

import json
import shutil
from pathlib import Path


def which(name: str) -> str | None:
    return shutil.which(name)


def _pcsc_ready() -> bool:
    try:
        # Windows: winscard.dll
        import ctypes
        ctypes.WinDLL('winscard')
        return True
    except Exception:
        pass
    try:
        import smartcard  # type: ignore
        return True
    except Exception:
        return False


def _javac_build_ready(root: Path) -> bool:
    # Consider JavaCard build ready if java exists and SDK jars (tools.jar + api) are present
    java = which('java')
    sdk_dir = root / 'sdk' / 'javacard' / 'lib'
    tools = sdk_dir / 'tools.jar'
    api = None
    for cand in ['api_classic.jar', 'javacard_framework.jar']:
        p = sdk_dir / cand
        if p.exists():
            api = p
            break
    return bool(java) and tools.exists() and (api is not None)


def check_readiness() -> bool:
    root = Path(__file__).parent
    return _javac_build_ready(root) and _pcsc_ready()


--- proposed excerpt ---
"""Minimal environment audit for GREENWIRE.

Provides aggregate(), human(), check_readiness(), and main() used by greenwire.py.
Checks: java, adb, gp.jar presence and version where applicable.
"""
from __future__ import annotations  # noqa: F401

import json, shutil
from pathlib import Path


def which(name: str) -> str | None:
    return shutil.which(name)


def _pcsc_ready() -> bool:
    try:
        # Windows: winscard.dll
        import ctypes
        ctypes.WinDLL('winscard')
        return True
    except Exception:
        pass
    try:
        import smartcard  # type: ignore
        return True
    except Exception:
        return False


def _javac_build_ready(root: Path) -> bool:
    # Consider JavaCard build ready if java exists and SDK jars (tools.jar + api) are present
    java = which('java')
    sdk_dir = root / 'sdk' / 'javacard' / 'lib'
    tools = sdk_dir / 'tools.jar'
    api = None
    for cand in ['api_classic.jar', 'javacard_framework.jar']:
        p = sdk_dir / cand
        if p.exists():
            api = p
            break
    return bool(java) and tools.exists() and (api is not None)


def check_readiness() -> bool:
    root = Path(__file__).parent
    return _javac_build_ready(root) and _pcsc_ready()


def aggregate() -> dict:
(dry-run)

Changes for .\tools\update_engineering_memory.py:
--- original excerpt ---
#!/usr/bin/env python3
"""
Generate or update docs/ENGINEERING_MEMORY-{YYYY-MM-DD}.md with a concise
snapshot of the current repo state: latest commits, open TODOs from code, and
key config diffs. Designed to be lightweight and runnable offline.

Usage:
  python tools/update_engineering_memory.py [--note "short summary"]

It will append a new top section for today's date or update it if already
present. It never rewrites older sections.
"""
from __future__ import annotations

import argparse
import datetime as dt
import os
import re
import subprocess
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[1]
DOCS_DIR = REPO_ROOT / "docs"
DOCS_DIR.mkdir(parents=True, exist_ok=True)


def run(cmd: list[str]) -> str:
    try:
        out = subprocess.run(cmd, cwd=str(REPO_ROOT), capture_output=True, text=True, check=False)
        return out.stdout.strip()
    except Exception as e:
        return f"<error: {e}>"


def get_git_summary() -> str:
    head = run(["git", "--no-pager", "log", "-n", "5", "--pretty=format:%h %ad %s", "--date=short"]) or "<no git log>"
    status = run(["git", "status", "--porcelain"]) or ""
    dirty = "clean" if not status else f"dirty (changes: {len(status.splitlines())})"
    branch = run(["git", "rev-parse", "--abbrev-ref", "HEAD"]) or "<no branch>"
    return f"Branch: {branch}\nState: {dirty}\nRecent commits:\n{head}"


def grep_todos() -> str:
    try:
        out = run(["git", "--no-pager", "grep", "-n", "TODO|FIXME|HACK", "--", "."])
        if not out:
            return "None found"
        # limit to 30 lines to keep snapshot short
        lines = out.splitlines()[:30]
        return "\n".join(lines)
--- proposed excerpt ---
#!/usr/bin/env python3
"""
Generate or update docs/ENGINEERING_MEMORY-{YYYY-MM-DD}.md with a concise
snapshot of the current repo state: latest commits, open TODOs from code, and
key config diffs. Designed to be lightweight and runnable offline.

Usage:
  python tools/update_engineering_memory.py [--note "short summary"]

It will append a new top section for today's date or update it if already
present. It never rewrites older sections.
"""
from __future__ import annotations  # noqa: F401

import argparse, datetime as dt, os, re, subprocess  # noqa: F401
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[1]
DOCS_DIR = REPO_ROOT / "docs"
DOCS_DIR.mkdir(parents=True, exist_ok=True)


def run(cmd: list[str]) -> str:
    try:
        out = subprocess.run(cmd, cwd=str(REPO_ROOT), capture_output=True, text=True, check=False)
        return out.stdout.strip()
    except Exception as e:
        return f"<error: {e}>"


def get_git_summary() -> str:
    head = run(["git", "--no-pager", "log", "-n", "5", "--pretty=format:%h %ad %s", "--date=short"]) or "<no git log>"
    status = run(["git", "status", "--porcelain"]) or ""
    dirty = "clean" if not status else f"dirty (changes: {len(status.splitlines())})"
    branch = run(["git", "rev-parse", "--abbrev-ref", "HEAD"]) or "<no branch>"
    return f"Branch: {branch}\nState: {dirty}\nRecent commits:\n{head}"


def grep_todos() -> str:
    try:
        out = run(["git", "--no-pager", "grep", "-n", "TODO|FIXME|HACK", "--", "."])
        if not out:
            return "None found"
        # limit to 30 lines to keep snapshot short
        lines = out.splitlines()[:30]
        return "\n".join(lines)
    except Exception:
        return "<grep not available>"


(dry-run)

Changes for .\tools\verify_java_static_setup.py:
--- original excerpt ---
#!/usr/bin/env python3
"""Quick audit for GREENWIRE Java static dependencies.

Ensures we can build CAP files without downloading external artifacts at build
time by verifying that mandatory jars are present inside the repository.
"""
from __future__ import annotations

import shutil
from pathlib import Path
import sys


REQUIRED_ITEMS = [
    ("lib/GlobalPlatformPro.jar", "GlobalPlatformPro jar (martinpaljak releases)"),
    ("static/java/gp.jar", "GlobalPlatformPro lightweight gp.jar"),
    ("static/java/ant-javacard.jar", "ant-javacard build helper"),
]

# Optional groups: at least one of the patterns in each group should exist
OPTIONAL_API_CANDIDATES = [
    "sdk/javacard/lib/api_classic-3.0.5.jar",
    "sdk/javacard/lib/api_classic.jar",
    "sdk/javacard/lib/javacard_framework.jar",
]
OPTIONAL_ITEMS = [
    (OPTIONAL_API_CANDIDATES, "JavaCard API (e.g., api_classic.jar or versioned variant)"),
    (["sdk/javacard/lib/tools.jar"], "JavaCard converter tools.jar (SDK)"),
]


def status(path: Path) -> str:
    return "✅" if path.exists() else "❌"


def main() -> int:
    root = Path(__file__).resolve().parents[1]
    print(f"📦 GREENWIRE static Java audit\nRoot: {root}\n")

    ok = True
    print("Mandatory items:")
    for rel, hint in REQUIRED_ITEMS:
        p = root / rel
        good = p.exists()
        print(f"  {status(p)} {rel}")
        if not good:
            ok = False
            print(f"     → missing: {hint}")

    print("\nOptional (recommended for full offline cap conversion):")
--- proposed excerpt ---
#!/usr/bin/env python3
"""Quick audit for GREENWIRE Java static dependencies.

Ensures we can build CAP files without downloading external artifacts at build
time by verifying that mandatory jars are present inside the repository.
"""
from __future__ import annotations  # noqa: F401

import shutil, sys
from pathlib import Path


REQUIRED_ITEMS = [
    ("lib/GlobalPlatformPro.jar", "GlobalPlatformPro jar (martinpaljak releases)"),
    ("static/java/gp.jar", "GlobalPlatformPro lightweight gp.jar"),
    ("static/java/ant-javacard.jar", "ant-javacard build helper"),
]

# Optional groups: at least one of the patterns in each group should exist
OPTIONAL_API_CANDIDATES = [
    "sdk/javacard/lib/api_classic-3.0.5.jar",
    "sdk/javacard/lib/api_classic.jar",
    "sdk/javacard/lib/javacard_framework.jar",
]
OPTIONAL_ITEMS = [
    (OPTIONAL_API_CANDIDATES, "JavaCard API (e.g., api_classic.jar or versioned variant)"),
    (["sdk/javacard/lib/tools.jar"], "JavaCard converter tools.jar (SDK)"),
]


def status(path: Path) -> str:
    return "✅" if path.exists() else "❌"


def main() -> int:
    root = Path(__file__).resolve().parents[1]
    print(f"📦 GREENWIRE static Java audit\nRoot: {root}\n")

    ok = True
    print("Mandatory items:")
    for rel, hint in REQUIRED_ITEMS:
        p = root / rel
        good = p.exists()
        print(f"  {status(p)} {rel}")
        if not good:
            ok = False
            print(f"     → missing: {hint}")

    print("\nOptional (recommended for full offline cap conversion):")
    for rels, hint in OPTIONAL_ITEMS:
(dry-run)
