import unittest
from unittest.mock import patch, mock_open, MagicMock
import time
import json

from greenwire.logger import CapFileLogger

class TestCapFileLogger(unittest.TestCase):
    def setUp(self):
        self.cap_file = "test.cap"
        self.log_file = f"{self.cap_file}.log.json"
        self.replay_file = f"{self.cap_file}.replay.json"
        self.suspicious_file = f"{self.cap_file}.suspicious.json"
        self.loghash_file = f"{self.cap_file}.loghash.txt"

    @patch("os.path.exists", return_value=False)
    @patch("builtins.open", new_callable=mock_open)
    def test_init_no_log(self, mock_file, mock_exists):
        logger = CapFileLogger(self.cap_file)
        self.assertEqual(logger.entries, [])
        self.assertFalse(logger.positive_mode)

    @patch("os.path.exists", return_value=True)
    @patch("builtins.open", new_callable=mock_open, read_data='[{"apdu": "00A40400", "response": "9000"}]')
    def test_init_with_log(self, mock_file, mock_exists):
        logger = CapFileLogger(self.cap_file)
        self.assertIsInstance(logger.entries, list)
        self.assertEqual(logger.entries[0]["apdu"], "00A40400")

    @patch("greenwire.logger.CapFileLogger.persist_logs_in_cap")
    @patch("builtins.open", new_callable=mock_open)
    def test_log_and_fingerprinting(self, mock_file, mock_persist):
        logger = CapFileLogger(self.cap_file)
        apdu = "80CA1234"
        response = "6A82"
        with patch.object(logger, "is_fingerprinting_apdu", return_value=True):
            with patch.object(logger, "log_suspicious") as mock_susp:
                logger.log("sent", apdu, response)
                self.assertEqual(logger.entries[-1]["response"], "9000")
                mock_susp.assert_called_once()
        with patch.object(logger, "is_fingerprinting_apdu", return_value=False):
            logger.log("sent", "00A40400", "9000")
            self.assertEqual(logger.entries[-1]["apdu"], "00A40400")

    @patch("builtins.open", new_callable=mock_open)
    def test_set_positive_mode(self, mock_file):
        logger = CapFileLogger(self.cap_file)
        logger.entries = []
        logger.set_positive_mode(True)
        self.assertTrue(logger.positive_mode)
        logger.entries = []
        logger.set_positive_mode(False)
        self.assertFalse(logger.positive_mode)

    @patch("builtins.open", new_callable=mock_open)
    def test_record_and_get_replay(self, mock_file):
        logger = CapFileLogger(self.cap_file)
        apdu = "00A40400"
        resp = "9000"
        logger.record_apdu_pair(apdu, resp)
        self.assertEqual(logger.get_replay_response(apdu), resp)
        self.assertIsNone(logger.get_replay_response("00B00000"))

    @patch("builtins.open", new_callable=mock_open, read_data='{"00A40400": "9000"}')
    def test_import_export_replay_log(self, mock_file):
        logger = CapFileLogger(self.cap_file)
        logger.import_replay_log(self.replay_file)
        self.assertEqual(logger.replay_pairs["00A40400"], "9000")
        logger.replay_pairs = {"00A40400": "9000"}
        logger.export_replay_log(self.replay_file)
        mock_file().write.assert_called()

    @patch("builtins.open", new_callable=mock_open)
    def test_log_suspicious_and_dump(self, mock_file):
        logger = CapFileLogger(self.cap_file)
        logger.log_suspicious("00A40400", "test reason")
        events = logger.dump_suspicious()
        self.assertEqual(events[-1]["apdu"], "00A40400")
        self.assertEqual(events[-1]["reason"], "test reason")

    @patch("builtins.open", new_callable=mock_open)
    def test_learn_from_session(self, mock_file):
        logger = CapFileLogger(self.cap_file)
        logger.entries = [
            {"apdu": "00A40400", "response": "9000"},
            {"apdu": "00B00000", "response": "6A82"}
        ]
        logger.suspicious_events = [
            {"apdu": "00A40400", "response": "9000"},
            {"apdu": "00B00000", "response": "6A82"}
        ]
        logger.record_apdu_pair = MagicMock()
        logger.learn_from_session()
        logger.record_apdu_pair.assert_called_with("00A40400", "9000")
        self.assertEqual(
            [e["apdu"] for e in logger.suspicious_events],
            ["00B00000"]
        )

    def test_is_fingerprinting_apdu(self):
        logger = CapFileLogger(self.cap_file)
        self.assertTrue(logger.is_fingerprinting_apdu("80CA1234"))
        self.assertFalse(logger.is_fingerprinting_apdu("00A40400"))

    @patch("builtins.open", new_callable=mock_open)
    def test_randomize_response_fields(self, mock_file):
        logger = CapFileLogger(self.cap_file)
        apdu = "00840000"
        resp = logger.randomize_response_fields(apdu)
        self.assertTrue(resp.endswith("9000") or resp is None)

    def test_is_ghost_applet(self):
        logger = CapFileLogger(self.cap_file)
        aid = logger.GHOST_APPLET_AIDS[0]
        self.assertTrue(logger.is_ghost_applet(aid))
        self.assertFalse(logger.is_ghost_applet("A00000000000000000"))

    @patch("greenwire.logger.CapFileLogger.log")
    def test_log_ghost_applet(self, mock_log):
        logger = CapFileLogger(self.cap_file)
        aid = logger.GHOST_APPLET_AIDS[0]
        logger.log_ghost_applet(aid, "00A40400")
        mock_log.assert_called_with('ghost_applet', "00A40400", f"Ghost applet {aid} interaction")

    @patch("builtins.open", new_callable=mock_open, read_data="#LOGS_START\nlogdata")
    @patch("greenwire.logger.hashlib.sha256")
    @patch("greenwire.logger.CapFileLogger.log")
    def test_seal_logs(self, mock_log, mock_sha256, mock_file):
        logger = CapFileLogger(self.cap_file)
        mock_sha256.return_value.hexdigest.return_value = "deadbeef"
        with patch("os.path.exists", return_value=True):
            logger.seal_logs()
            mock_log.assert_any_call('seal', 'LOGS', "Log area sealed with hash deadbeef")

    def test_log_timing(self):
        logger = CapFileLogger(self.cap_file)
        with patch.object(logger, "log_suspicious") as mock_susp:
            t0 = time.time()
            time.sleep(0.06)
            logger.log_timing("00A40400", t0)
            # Should not call suspicious for normal timing
            mock_susp.assert_not_called()
            # Simulate fast timing
            logger.log_timing("00A40400", time.time())
            # Simulate slow timing
            logger.log_timing("00A40400", time.time() - 3)



if __name__ == "__main__":
    unittest.main()
